app\admin\page.tsx
import { currentUser } from '@clerk/nextjs/server';
  import PostList from '@/components/PostList';

  export default async function AdminPanel() {
    const user = await currentUser();

    if (!user) {
      return (
        <div className="container">
          <h1 className="admin-title">خطا</h1>
          <p className="admin-error">برای دسترسی به ادمین پنل وارد شوید</p>
        </div>
      );
    }

    const isAdmin = user.publicMetadata?.role === 'admin';

    if (!isAdmin) {
      return (
        <div className="container">
          <h1 className="admin-title">خطا</h1>
          <p className="admin-error">فقط ادمین‌ها به این صفحه دسترسی دارند</p>
        </div>
      );
    }

    return (
      <div className="container">
        <h1 className="admin-title">ادمین پنل</h1>
        <PostList searchQuery="" isAllPosts={true} isAdmin={true} deleteAdmin={true} />
      </div>
    );
  }

app\all-posts\page.tsx
import PostList from "@/components/PostList";
import SearchBox from "@/components/SearchBox";
import TopPosts from "../components/TopPosts";
import RecentPosts from "../components/RecentPosts";

export default function AllPosts({ searchParams }: { searchParams: { q?: string } }) {
  const searchQuery = searchParams.q || '';

  return (
    <div className="container">
      <TopPosts/>
      <RecentPosts/>
      <h2 style={{ fontSize: '1.75rem', fontWeight: 600, marginBottom: '16px' }}>
      </h2>
      <p style={{ marginBottom: '16px', color: '#4b5563' }}>
        All Post`s are here
      </p>
      <SearchBox defaultValue={searchQuery} formAction="/all-posts" />
      <PostList searchQuery={searchQuery} isAllPosts={true} />
    </div>
  );
}

app\api\comments\post\[postId]\route.ts
import { NextResponse } from 'next/server';
import { currentUser } from '@clerk/nextjs/server';
import db, { connectDB } from '@/lib/surrealdb';
import { clerkClient } from '@clerk/nextjs/server';

type Comment = {
  id: string;
  postId: string;
  content: string;
  author: string;
  created_at: string;
  parentId?: string | null;
  authorName?: string;
  replies?: Comment[];
};

export async function GET(request: Request, context: { params: Promise<{ postId: string }> }) {
  try {
    const user = await currentUser();
    if (!user) {
      return NextResponse.json({ error: 'لطفاً وارد شوید' }, { status: 401 });
    }

    const params = await context.params;
    const postId = `posts:${params.postId}`;

    await connectDB();
    const sql = `SELECT * FROM comments WHERE postId = $postId ORDER BY created_at DESC`;
    const result = await db.query<Comment[]>(sql, { postId });

    let comments: Comment[] = Array.isArray(result[0]) ? result[0] : [];

    const enrichedComments = await Promise.all(
      comments.map(async (comment) => {
        const clerk = await clerkClient();
        const user = await clerk.users.getUser(comment.author);
        const authorName = user.firstName || user.emailAddresses[0]?.emailAddress || 'ناشناس';
        return {
          ...comment,
          authorName,
          replies: [],
          id: comment.id.toString(),
          parentId: comment.parentId ? comment.parentId.toString() : null
        };
      })
    );

    const commentMap = new Map<string, Comment>();
    const rootComments: Comment[] = [];

    enrichedComments.forEach((comment) => {
      commentMap.set(comment.id, comment);
    });

    enrichedComments.forEach((comment) => {
      if (!comment.parentId) {
        rootComments.push(comment);
      } else {
        const parent = commentMap.get(comment.parentId);
        if (parent) {
          parent.replies = parent.replies || [];
          parent.replies.push(comment);
        }
      }
    });

    return NextResponse.json(rootComments, { status: 200 });
  } catch (error: any) {
    return NextResponse.json({ error: 'خطا تو سرور', details: error.message }, { status: 500 });
  }
}

app\api\comments\route.ts
import { NextResponse } from 'next/server';
import { currentUser } from '@clerk/nextjs/server';
import db, { connectDB } from '@/lib/surrealdb';
import { RecordId } from 'surrealdb';

export async function POST(request: Request) {
  try {
    const user = await currentUser();
    if (!user) {
      return NextResponse.json({ error: 'لطفاً وارد شوید' }, { status: 401 });
    }

    const { postId, content, parentId } = await request.json();
    if (!postId || !content) {
      return NextResponse.json({ error: 'پست یا محتوا خالیه' }, { status: 400 });
    }

    const postIdString = postId.startsWith('posts:') ? postId : `posts:${postId}`;
    let parentIdRecord = null;
    if (parentId) {
      const parentIdString = parentId.startsWith('comments:') ? parentId : `comments:${parentId}`;
      parentIdRecord = new RecordId('comments', parentIdString.split(':')[1]);
    }

    await connectDB();
    const newComment = await db.create('comments', {
      postId: postIdString,
      content,
      author: user.id,
      created_at: new Date().toISOString(),
      parentId: parentIdRecord,
    });

    return NextResponse.json(newComment, { status: 201 });
  } catch (error: any) {
    return NextResponse.json({ error: 'خطا تو سرور', details: error.message }, { status: 500 });
  }
}

app\api\comments\[commentId]\route.ts
import { NextResponse } from 'next/server';
import { currentUser } from '@clerk/nextjs/server';
import db, { connectDB } from '@/lib/surrealdb';
import { RecordId } from 'surrealdb';

type Comment = {
  id: string;
  postId: string;
  content: string;
  author: string;
  created_at: string;
  parentId?: string | null;
};

export async function DELETE(req: Request, { params }: { params: { commentId: string } }) {
  try {
    const user = await currentUser();
    if (!user) {
      console.error('DELETE ERROR => No user authenticated');
      return NextResponse.json({ error: 'لطفاً وارد شوید' }, { status: 401 });
    }

    await connectDB();
    const { commentId } = params;
    if (!commentId) {
      console.error('DELETE ERROR => Invalid commentId:', commentId);
      return NextResponse.json({ error: 'شناسه کامنت نامعتبر است' }, { status: 400 });
    }

    const recordId = new RecordId('comments', commentId);
    console.log('DELETE ID =>', commentId);
    console.log('RECORD ID =>', recordId);

    // Fetch comment to check ownership
    console.log(`Before fetching comment: ${recordId}`);
    const comment = await db.select<Comment>(recordId);
    if (!comment) {
      console.error('DELETE ERROR => Comment not found:', recordId);
      return NextResponse.json({ error: 'کامنت یافت نشد' }, { status: 404 });
    }

    console.log('Comment author:', comment.author, 'User ID:', user.id);
    if (comment.author !== user.id) {
      console.error('DELETE ERROR => Unauthorized: User does not own comment');
      return NextResponse.json({ error: 'فقط نویسنده کامنت می‌تواند آن را حذف کند' }, { status: 403 });
    }

    // Perform deletion
    console.log(`Before deleting comment: ${recordId}`);
    await db.delete(recordId);
    console.log('DELETE RESULT =>', 'Comment deleted');

    console.log(`Comment deleted: ${recordId}`);
    return NextResponse.json({ message: 'کامنت با موفقیت حذف شد' }, { status: 200 });
  } catch (error: any) {
    console.error('DELETE ERROR =>', error.message);
    return NextResponse.json(
      { error: 'خطا در حذف کامنت', details: error.message },
      { status: 500 }
    );
  }
}

app\api\favorites\user\route.ts
import { NextResponse } from 'next/server';
import { currentUser, clerkClient } from '@clerk/nextjs/server';
import db, { connectDB } from '@/lib/surrealdb';
import { RecordId } from 'surrealdb';

type Favorite = {
  id: string | RecordId;
  postId: string | RecordId;
  userId: string;
  created_at: string;
};

type Post = {
  id: string;
  title: string;
  content: string;
  author: string;
  created_at: string;
  imageUrl?: string;
  authorName: string;
  updated_at?: string;
};

export async function GET(request: Request) {
  try {
    const user = await currentUser();
    if (!user) {
      return NextResponse.json({ error: 'Please sign in to view favorites' }, { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    const query = searchParams.get('q')?.trim() || '';

    await connectDB();

    // Get all favorites for the user
    const favoritesResult = await db.query<Favorite[]>(
      `SELECT * FROM favorites WHERE userId = $userId`,
      { userId: user.id }
    );

    let favorites: Favorite[] = Array.isArray(favoritesResult[0]) ? favoritesResult[0] : [];
    console.log('Favorites:', favorites); // Log favorites for debugging

    // Extract postIds and convert to RecordId format
    const postIds = favorites.map((fav) => {
      const postId = typeof fav.postId === 'string' ? fav.postId : fav.postId.toString();
      const identifier = postId.startsWith('posts:') ? postId.replace('posts:', '') : postId;
      return new RecordId('posts', identifier);
    });
    console.log('PostIds:', postIds); // Log postIds for debugging

    if (postIds.length === 0) {
      return NextResponse.json([], { status: 200 });
    }

    // Fetch posts
    let posts: Post[] = [];
    if (query) {
      const postsResult = await db.query<Post[]>(
        `SELECT * FROM posts WHERE id IN $postIds AND (title ~ $query OR content ~ $query)`,
        { postIds, query }
      );
      posts = Array.isArray(postsResult[0]) ? postsResult[0] : [];
    } else {
      const postsResult = await db.query<Post[]>(
        `SELECT * FROM posts WHERE id IN $postIds`,
        { postIds }
      );
      posts = Array.isArray(postsResult[0]) ? postsResult[0] : [];
    }
    console.log('Fetched posts:', posts); // Log posts for debugging

    // Enrich posts with authorName from Clerk
    const enrichedPosts = await Promise.all(
      posts.map(async (post) => {
        try {
          console.log(`Fetching user for author ID: ${post.author}`);
          const clerk = await clerkClient();
          const clerkUser = await clerk.users.getUser(post.author);
          const authorName =
            clerkUser.firstName ||
            clerkUser.fullName ||
            clerkUser.emailAddresses[0]?.emailAddress ||
            'ایمیل نامشخص';
          console.log(`Author name: ${authorName}`);
          return { ...post, authorName, favorited_at: favorites.find((fav) => {
            const favPostId = typeof fav.postId === 'string' ? fav.postId : fav.postId.toString();
            return favPostId === post.id;
          })?.created_at };
        } catch (error: any) {
          console.error(`Error fetching user ${post.author}:`, error.message);
          return { ...post, authorName: 'ایمیل نامشخص', favorited_at: favorites.find((fav) => {
            const favPostId = typeof fav.postId === 'string' ? fav.postId : fav.postId.toString();
            return favPostId === post.id;
          })?.created_at };
        }
      })
    );

    console.log('Enriched posts:', enrichedPosts); // Log enriched posts for debugging
    return NextResponse.json(enrichedPosts, { status: 200 });
  } catch (error: any) {
    console.error('FETCH USER FAVORITES ERROR =>', error.message);
    return NextResponse.json(
      { error: 'Error fetching user favorites', details: error.message },
      { status: 500 }
    );
  }
}

app\api\favorites\[postId]\route.ts
import { NextResponse } from 'next/server';
import { currentUser } from '@clerk/nextjs/server';
import db, { connectDB } from '@/lib/surrealdb';
import { RecordId } from 'surrealdb';

type Favorite = {
  id: string | RecordId;
  postId: string;
  userId: string;
  created_at: string;
};

export async function POST(
  request: Request,
  { params }: { params: Promise<{ postId: string }> }
) {
  try {
    const user = await currentUser();
    if (!user) {
      return NextResponse.json({ error: 'Please sign in to add to favorites' }, { status: 401 });
    }

    const { postId } = await params;
    const postIdString = `posts:${postId}`;

    await connectDB();

    // Check if the user has already favorited the post
    const existingFavorite = await db.query<Favorite[]>(
      `SELECT * FROM favorites WHERE postId = $postId AND userId = $userId`,
      { postId: postIdString, userId: user.id }
    );

    let favorites: Favorite[] = Array.isArray(existingFavorite[0]) ? existingFavorite[0] : [];

    if (favorites.length > 0) {
      // User has already favorited, so remove from favorites
      const favoriteId = favorites[0].id;
      let favoriteIdString: string;

      if (typeof favoriteId === 'string') {
        favoriteIdString = favoriteId.includes(':') ? favoriteId.split(':')[1] : favoriteId;
      } else if (favoriteId instanceof RecordId) {
        favoriteIdString = String(favoriteId.id);
      } else {
        throw new Error('Invalid favorite ID format');
      }

      await db.delete(new RecordId('favorites', favoriteIdString));
      return NextResponse.json({ message: 'Removed from favorites', favorited: false }, { status: 200 });
    } else {
      // Add to favorites
      const newFavorite = await db.create('favorites', {
        postId: postIdString,
        userId: user.id,
        created_at: new Date().toISOString(),
      });

      return NextResponse.json({ message: 'Added to favorites', favorited: true, favorite: newFavorite }, { status: 201 });
    }
  } catch (error: any) {
    console.error('FAVORITE ERROR =>', error.message);
    return NextResponse.json(
      { error: 'Error processing favorite', details: error.message },
      { status: 500 }
    );
  }
}

export async function GET(
  request: Request,
  { params }: { params: Promise<{ postId: string }> }
) {
  try {
    const user = await currentUser();
    const { postId } = await params;
    const postIdString = `posts:${postId}`;

    await connectDB();

    // Get all favorites for the post
    const favoritesResult = await db.query<Favorite[]>(
      `SELECT * FROM favorites WHERE postId = $postId`,
      { postId: postIdString }
    );

    let favorites: Favorite[] = Array.isArray(favoritesResult[0]) ? favoritesResult[0] : [];

    // Check if the current user has favorited the post
    let userFavorited = false;
    if (user) {
      const userFavorite = await db.query<Favorite[]>(
        `SELECT * FROM favorites WHERE postId = $postId AND userId = $userId`,
        { postId: postIdString, userId: user.id }
      );
      userFavorited = Array.isArray(userFavorite[0]) && userFavorite[0].length > 0;
    }

    return NextResponse.json(
      { favoritesCount: favorites.length, userFavorited },
      { status: 200 }
    );
  } catch (error: any) {
    console.error('FETCH FAVORITES ERROR =>', error.message);
    return NextResponse.json(
      { error: 'Error fetching favorites', details: error.message },
      { status: 500 }
    );
  }
}

app\api\likes\[postId]\route.ts
import { NextResponse } from 'next/server';
import { currentUser } from '@clerk/nextjs/server';
import db, { connectDB } from '@/lib/surrealdb';
import { RecordId } from 'surrealdb';

type Like = {
  id: string | RecordId;
  postId: string;
  userId: string;
  created_at: string;
};

export async function POST(
  request: Request,
  { params }: { params: Promise<{ postId: string }> }
) {
  try {
    const user = await currentUser();
    if (!user) {
      return NextResponse.json({ error: 'Please sign in' }, { status: 401 });
    }

    const { postId } = await params;
    const postIdString = `posts:${postId}`;

    await connectDB();

    // Check if the user has already liked the post
    const existingLike = await db.query<Like[]>(
      `SELECT * FROM likes WHERE postId = $postId AND userId = $userId`,
      { postId: postIdString, userId: user.id }
    );

    let likes: Like[] = Array.isArray(existingLike[0]) ? existingLike[0] : [];

    if (likes.length > 0) {
      // User has already liked, so unlike (delete the like)
      const likeId = likes[0].id;
      let likeIdString: string;

      if (typeof likeId === 'string') {
        likeIdString = likeId.includes(':') ? likeId.split(':')[1] : likeId;
      } else if (likeId instanceof RecordId) {
        likeIdString = String(likeId.id);
      } else {
        throw new Error('Invalid like ID format');
      }

      await db.delete(new RecordId('likes', likeIdString));
      return NextResponse.json({ message: 'Like removed', liked: false }, { status: 200 });
    } else {
      // Create a new like
      const newLike = await db.create('likes', {
        postId: postIdString,
        userId: user.id,
        created_at: new Date().toISOString(),
      });

      return NextResponse.json({ message: 'Like added', liked: true, like: newLike }, { status: 201 });
    }
  } catch (error: any) {
    console.error('LIKE ERROR =>', error.message);
    return NextResponse.json(
      { error: 'Error processing like', details: error.message },
      { status: 500 }
    );
  }
}

export async function GET(
  request: Request,
  { params }: { params: Promise<{ postId: string }> }
) {
  try {
    const user = await currentUser();
    const { postId } = await params;
    const postIdString = `posts:${postId}`;

    await connectDB();

    // Get all likes for the post
    const likesResult = await db.query<Like[]>(
      `SELECT * FROM likes WHERE postId = $postId`,
      { postId: postIdString }
    );

    let likes: Like[] = Array.isArray(likesResult[0]) ? likesResult[0] : [];

    // Check if the current user has liked the post
    let userLiked = false;
    if (user) {
      const userLike = await db.query<Like[]>(
        `SELECT * FROM likes WHERE postId = $postId AND userId = $userId`,
        { postId: postIdString, userId: user.id }
      );
      userLiked = Array.isArray(userLike[0]) && userLike[0].length > 0;
    }

    return NextResponse.json(
      { likesCount: likes.length, userLiked },
      { status: 200 }
    );
  } catch (error: any) {
    console.error('FETCH LIKES ERROR =>', error.message);
    return NextResponse.json(
      { error: 'Error fetching likes', details: error.message },
      { status: 500 }
    );
  }
}

app\api\posts\by-author\[authorId]\route.ts
import { NextResponse } from 'next/server';
  import { clerkClient } from '@clerk/nextjs/server';
  import db, { connectDB } from '@/lib/surrealdb';

  type Post = {
    id: string;
    title: string;
    content: string;
    author: string;
    created_at: string;
    imageUrl?: string;
    authorName: string;
  };

  export async function GET(req: Request, { params }: { params: { authorId: string } }) {
    try {
      const { authorId } = params;

      await connectDB();

      const sql = `SELECT * FROM posts WHERE author = $author ORDER BY created_at DESC`;
      const result = await db.query<Post[]>(sql, { author: authorId });
      let posts: Post[] = [];
      if (Array.isArray(result)) {
        posts = Array.isArray(result[0]) ? result[0] : result;
      } else if (Array.isArray((result[0] as any)?.result)) {
        posts = (result[0] as { result: Post[] }).result;
      }

      const enrichedPosts = await Promise.all(
        posts.map(async (post) => {
          try {
            console.log(`Fetching user for author ID: ${post.author}`);
            const clerk = await clerkClient();
            const clerkUser = await clerk.users.getUser(post.author);
            const authorName =
              clerkUser.firstName || clerkUser.fullName || clerkUser.emailAddresses[0]?.emailAddress || 'ایمیل نامشخص';
            console.log(`Author name: ${authorName}`);
            return { ...post, authorName };
          } catch (error: any) {
            console.error(`Error fetching user ${post.author}:`, error.message);
            return { ...post, authorName: 'ایمیل نامشخص' };
          }
        })
      );

      console.log(`Fetched ${enrichedPosts.length} posts for author ${authorId}`);
      return NextResponse.json(enrichedPosts, { status: 200 });
    } catch (error: any) {
      console.error('FETCH AUTHOR POSTS ERROR =>', error.message);
      return NextResponse.json(
        { error: 'خطا در دریافت پست‌ها', details: error.message },
        { status: 500 }
      );
    }
  }

app\api\posts\route.ts
import { NextResponse } from 'next/server'
import { currentUser, clerkClient } from '@clerk/nextjs/server'
import db, { connectDB } from '@/lib/surrealdb'

type Post = {
  id: string
  title: string
  content: string
  author: string
  created_at: string
  imageUrl?: string
  authorName: string
  updated_at?: string
}

export async function GET(req: Request) {
  try {
    const { searchParams } = new URL(req.url)
    const limit = parseInt(searchParams.get('limit') || '0') || 0

    await connectDB()

    let sql = `SELECT * FROM posts ORDER BY created_at DESC`
    if (limit > 0) {
      sql += ` LIMIT ${limit}`
    }

    const result = await db.query<Post[]>(sql)
    let posts: Post[] = []
    if (Array.isArray(result)) {
      posts = Array.isArray(result[0]) ? result[0] : result
    } else if (Array.isArray((result[0] as any)?.result)) {
      posts = (result[0] as { result: Post[] }).result
    }

    const enrichedPosts = await Promise.all(
      posts.map(async (post) => {
        try {
          console.log(`Fetching user for author ID: ${post.author}`)
          const clerk = await clerkClient()
          const clerkUser = await clerk.users.getUser(post.author)
          const authorName =
            clerkUser.firstName ||
            clerkUser.fullName ||
            clerkUser.emailAddresses[0]?.emailAddress ||
            'ایمیل نامشخص'
          console.log(`Author name: ${authorName}`)
          return { ...post, authorName }
        } catch (error: any) {
          console.error(`Error fetching user ${post.author}:`, error.message)
          return { ...post, authorName: 'ایمیل نامشخص' }
        }
      })
    )

    console.log(`Fetched ${enrichedPosts.length} posts`)
    return NextResponse.json(enrichedPosts, { status: 200 })
  } catch (error: any) {
    console.error('FETCH POSTS ERROR =>', error.message)
    return NextResponse.json(
      { error: 'خطا در دریافت پست‌ها', details: error.message },
      { status: 500 }
    )
  }
}

export async function POST(request: Request) {
  try {
    const user = await currentUser()
    if (!user) {
      return NextResponse.json({ error: 'کاربر احراز هویت نشده' }, { status: 401 })
    }

    const { title, content, imageUrl } = await request.json()
    if (!title || !content) {
      return NextResponse.json({ error: 'عنوان و محتوا الزامی است' }, { status: 400 })
    }

    await connectDB()
    const newPost = await db.create('posts', {
      title,
      content,
      imageUrl: imageUrl || null,
      author: user.id,
      created_at: new Date().toISOString(),
    })

    return NextResponse.json(newPost, { status: 201 })
  } catch (error: any) {
    console.error('CREATE POST ERROR =>', error.message)
    return NextResponse.json({ error: 'خطا در ایجاد پست', details: error.message }, { status: 500 })
  }
}

app\api\posts\search\route.ts
import { NextResponse } from 'next/server'
import { currentUser, clerkClient } from '@clerk/nextjs/server'
import db, { connectDB } from '@/lib/surrealdb'

type Post = {
  id: string
  title: string
  content: string
  author: string
  created_at: string
  authorName: string
}

export async function GET(req: Request) {
  try {
    const user = await currentUser()
    if (!user) {
      return NextResponse.json({ error: 'User not authenticated' }, { status: 401 })
    }

    const { searchParams } = new URL(req.url)
    const query = searchParams.get('q')?.trim()

    if (!query) {
      return NextResponse.json({ error: 'Search query is required' }, { status: 400 })
    }

    await connectDB()

    const sql = `
             SELECT * FROM posts
             WHERE title ~ $query OR content ~ $query
             ORDER BY created_at DESC
           `
    const params = { query }

    const result = await db.query<Post[]>(sql, params)
    let posts: Post[] = []
    if (Array.isArray(result)) {
      posts = Array.isArray(result[0]) ? result[0] : result
    } else if (Array.isArray((result[0] as any)?.result)) {
      posts = (result[0] as { result: Post[] }).result
    }

    const enrichedPosts = await Promise.all(
      posts.map(async (post) => {
        try {
          console.log(`Fetching user for author ID: ${post.author}`)
          const clerk = await clerkClient()
          const clerkUser = await clerk.users.getUser(post.author)
          const authorName = clerkUser.emailAddresses[0]?.emailAddress || 'Unknown email'
          console.log(`Clerk user email: ${authorName}`)
          return { ...post, authorName }
        } catch (error: any) {
          console.error(`Error fetching user ${post.author}:`, error.message)
          return { ...post, authorName: 'Unknown email' }
        }
      })
    )

    console.log(`Found ${enrichedPosts.length} posts for query: ${query}`)
    return NextResponse.json(enrichedPosts, { status: 200 })
  } catch (error: any) {
    console.error('SEARCH ERROR =>', error.message)
    return NextResponse.json(
      { error: 'Failed to search posts', details: error.message },
      { status: 500 }
    )
  }
}


app\api\posts\top\route.ts
import db, { connectDB } from "@/lib/surrealdb";
import { clerkClient } from "@clerk/nextjs/server";
import { NextResponse } from "next/server";

export async function GET() {
  try {
    console.log('Attempting to connect to SurrealDB...');
    await connectDB();
    console.log('Connected to SurrealDB successfully.');

    // گرفتن همه لایک‌ها
    const likesSql = 'SELECT * FROM likes';
    console.log('Executing likes query:', likesSql);
    const likesResult: any = await db.query(likesSql);
    console.log('Raw likes result:', JSON.stringify(likesResult, null, 2));

    type Like = { postId: string }; // Define the Like type
    let likes: Like[] = [];
    if (Array.isArray(likesResult)) {
      likes = Array.isArray(likesResult[0]) ? likesResult[0] : likesResult;
    } else if (likesResult[0]?.result) {
      likes = likesResult[0].result;
    }

    // ساخت مپ برای شمارش لایک‌ها بر اساس postId
    const likesCountMap: { [key: string]: number } = {};
    likes.forEach((like) => {
      likesCountMap[like.postId] = (likesCountMap[like.postId] || 0) + 1;
    });
    console.log('Likes count map:', JSON.stringify(likesCountMap, null, 2));

    // گرفتن پست‌ها
    const postsSql = `
      SELECT 
        id,
        title,
        content,
        author,
        created_at,
        imageUrl,
        updated_at
      FROM posts
    `;
    console.log('Executing posts query:', postsSql);

    const result: any = await db.query(postsSql);
    console.log('Raw query result:', JSON.stringify(result, null, 2));

    // Define the Post type
    type Post = {
      id: string;
      title: string;
      content: string;
      author: string;
      created_at: string;
      imageUrl?: string;
      updated_at?: string;
      likesCount?: number;
    };
    
        let posts: Post[] = [];
    if (Array.isArray(result)) {
      posts = Array.isArray(result[0]) ? result[0] : result;
    } else if (result[0]?.result) {
      posts = result[0].result;
    } else {
      console.warn('Unexpected query result format:', result);
      posts = [];
    }

    // اضافه کردن likesCount از مپ
    posts = posts.map((post) => ({
      ...post,
      likesCount: likesCountMap[post.id] || 0,
    }));

    // مرتب‌سازی بر اساس تعداد لایک (نزولی) و سپس زمان (صعودی)
    posts = posts
      .sort((a, b) => {
        if ((b.likesCount || 0) === (a.likesCount || 0)) {
          return new Date(a.created_at).getTime() - new Date(b.created_at).getTime();
        }
        return (b.likesCount || 0) - (a.likesCount || 0);
      })
      .slice(0, 3); // انتخاب 3 پست برتر

    console.log('Parsed posts:', JSON.stringify(posts, null, 2));

    posts = posts.filter(
      (post) => post && typeof post === 'object' && post.id && post.title && post.author
    );

    if (posts.length === 0) {
      console.log('No posts found.');
      return NextResponse.json([], { status: 200 });
    }

    const enrichedPosts = await Promise.all(
      posts.map(async (post) => {
        try {
          console.log(`Fetching user for author ID: ${post.author}`);
          const clerk = await clerkClient();
          const clerkUser = await clerk.users.getUser(post.author);
          const authorName =
            clerkUser.firstName ||
            clerkUser.fullName ||
            clerkUser.emailAddresses[0]?.emailAddress ||
            'ایمیل نامشخص';
          console.log(`Author name for ${post.author}: ${authorName}`);
          return { ...post, authorName, likesCount: post.likesCount };
        } catch (error: any) {
          console.error(`Error fetching user ${post.author}:`, error.message);
          return { ...post, authorName: 'ایمیل نامشخص', likesCount: post.likesCount };
        }
      })
    );

    console.log(`Returning ${enrichedPosts.length} top posts`);
    return NextResponse.json(enrichedPosts, { status: 200 });
  } catch (error: any) {
    console.error('FETCH TOP POSTS ERROR =>', error.message, error.stack);
    return NextResponse.json(
      { error: 'خطا در دریافت پست‌های برتر', details: error.message },
      { status: 500 }
    );
  }
}


app\api\posts\[id]\delete\route.ts
import { NextResponse } from 'next/server';
     import { currentUser } from '@clerk/nextjs/server';
     import db, { connectDB } from '@/lib/surrealdb';
import { RecordId } from 'surrealdb';

     type Post = {
       id: string;
       title: string;
       content: string;
       author: string;
       created_at: string;
     };

     export async function DELETE(req: Request, { params }: { params: { id: string } }) {
       try {
         const user = await currentUser();
         if (!user) {
           return NextResponse.json({ error: 'User not authenticated' }, { status: 401 });
         }

         await connectDB();
         const { id } = params;
         const postId = new RecordId('posts', id); // استفاده از RecordId به جای رشته خام

         console.log('DELETE ID =>', id);
         console.log('RECORD ID =>', postId);

         

         // Perform deletion
         console.log(`Before deleting post: ${postId}`);
         await db.delete(postId);
         console.log('DELETE RESULT =>', 'Post deleted');

         console.log(`Post deleted: ${postId}`);
         return NextResponse.json({ message: 'Post deleted successfully' }, { status: 200 });
       } catch (error: any) {
         console.error('DELETE ERROR =>', error.message);
         return NextResponse.json(
           { error: 'Failed to delete post', details: error.message },
           { status: 500 }
         );
       }
     }

app\api\posts\[id]\route.ts
import { NextRequest, NextResponse } from 'next/server';
import { currentUser, clerkClient } from '@clerk/nextjs/server';
import db, { connectDB } from '@/lib/surrealdb';
import { RecordId } from 'surrealdb';

type Post = {
  id: string;
  title: string;
  content: string;
  author: string;
  created_at: string;
  imageUrl?: string;
  updated_at?: string;
  authorName?: string;
};

export async function GET(req: NextRequest, { params }: { params: { id: string } }) {
  try {
    // احراز هویت با Clerk
    const user = await currentUser();
    if (!user) {
      console.log('کاربر احراز هویت نشده');
      return NextResponse.json({ error: 'کاربر احراز هویت نشده' }, { status: 401 });
    }

    // اتصال به SurrealDB
    await connectDB();

    const { id } = params;
    const postId = new RecordId('posts', id);
    console.log(`تلاش برای دریافت پست با شناسه: ${postId}`);

    // استفاده از db.select برای گرفتن پست
    const result = await db.select<Post>(postId);
    console.log('داده پست دریافت‌شده:', result);

    // چک کردن اینکه نتیجه خالی نیست
    if (!result) {
      console.log(`پست پیدا نشد: ${postId}`);
      return NextResponse.json({ error: 'پست پیدا نشد' }, { status: 404 });
    }

    // گرفتن اطلاعات نویسنده از Clerk
    let post: Post = result;
    if (post.author) {
      try {
        const clerk = await clerkClient();
        const clerkUser = await clerk.users.getUser(post.author);
        post.authorName = clerkUser.firstName || clerkUser.fullName || clerkUser.emailAddresses[0]?.emailAddress || 'ناشناس';
      } catch (error: any) {
        console.error(`خطا در گرفتن اطلاعات کاربر از Clerk: ${error.message}`);
        post.authorName = 'ناشناس';
      }
    }

    console.log(`پست دریافت شد: ${postId}`);
    return NextResponse.json(post, { status: 200 });
  } catch (error: any) {
    console.error(`خطا در دریافت پست: ${error.message}`);
    return NextResponse.json(
      { error: 'خطا در دریافت پست', جزئیات: error.message },
      { status: 500 }
    );
  }
}

app\api\posts\[id]\update\route.ts
import { NextResponse } from 'next/server';
import { currentUser } from '@clerk/nextjs/server';
import db, { connectDB } from '@/lib/surrealdb';
import { RecordId } from 'surrealdb';

type Post = {
  id: string;
  title: string;
  content: string;
  author: string;
  created_at: string;
  imageUrl?: string;
  updated_at: string;
};

export async function PUT(req: Request, { params }: { params: { id: string } }) {
  try {
    const user = await currentUser();
    if (!user) {
      return NextResponse.json({ error: 'User not authenticated' }, { status: 401 });
    }

    await connectDB();
    const { id } = await params;
    const postId = new RecordId('posts', id);
    console.log('UPDATE ID =>', id);
    console.log('RECORD ID =>', postId.toString());
    const { title, content, imageUrl } = await req.json();
    const post = await db.select<Post>(postId);
    if (!post) {
      return NextResponse.json({ error: 'Post not found' }, { status: 404 });
    }

    if (post.author !== user.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 403 });
    }

    const updatedPost = await db.merge<Post>(postId, {
      title,
      content,
      imageUrl: imageUrl !== undefined ? imageUrl : post.imageUrl, // بررسی مقدار undefined برای تصویر
      updated_at: new Date().toISOString(),
    });
    if (!title || !content) {
      return NextResponse.json({ error: 'Title and content are required' }, { status: 400 });
    }
    return NextResponse.json(updatedPost, { status: 200 });
  } catch (error: any) {
    return NextResponse.json({ error: 'Failed to update post', details: error.message }, { status: 500 });
  }
}

app\api\upload-image\route.ts
// فایل: app/api/upload-image/route.ts
import { NextResponse } from 'next/server'
import { v2 as cloudinary } from 'cloudinary'

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME!,
  api_key: process.env.CLOUDINARY_API_KEY!,
  api_secret: process.env.CLOUDINARY_API_SECRET!,
})

export async function POST(req: Request) {
  try {
    console.log('📩 آپلود شروع شد')

    const formData = await req.formData()
    const file = formData.get('image') as File

    if (!file) {
      console.log('⚠️ فایل پیدا نشد')
      return NextResponse.json({ error: 'No file uploaded' }, { status: 400 })
    }

    const buffer = Buffer.from(await file.arrayBuffer())

    console.log('✅ فایل دریافت شد:', file.name)

    const uploadResult = await new Promise<{ url: string }>((resolve, reject) => {
      cloudinary.uploader
        .upload_stream({ folder: 'blog-posts' }, (error, result) => {
          // تغییر: استفاده از "blog-posts"
          if (error || !result) {
            console.log('❌ خطا در cloudinary:', error)
            return reject(error)
          }
          resolve({ url: result.secure_url })
        })
        .end(buffer)
    })

    console.log('✅ آپلود موفق:', uploadResult.url)

    return NextResponse.json({ url: uploadResult.url }, { status: 200 })
  } catch (err: any) {
    console.error('❌ خطای کلی سرور در upload route:', err)
    return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 })
  }
}


app\api\user-posts\route.ts
import { NextResponse } from 'next/server';
import { currentUser, clerkClient } from '@clerk/nextjs/server';
import db, { connectDB } from '@/lib/surrealdb';

type Post = {
  id: string;
  title: string;
  content: string;
  author: string;
  created_at: string;
  imageUrl?: string;
  authorName: string;
};

export async function GET(req: Request) {
  try {
    const user = await currentUser();
    if (!user) {
      return NextResponse.json({ error: 'کاربر احراز هویت نشده' }, { status: 401 });
    }

    await connectDB();

    const sql = `SELECT * FROM posts WHERE author = $author ORDER BY created_at DESC`;
    const params = { author: user.id };
    const result = await db.query<Post[]>(sql, params);
    let posts: Post[] = [];
    if (Array.isArray(result)) {
      posts = Array.isArray(result[0]) ? result[0] : result;
    } else if (Array.isArray((result[0] as any)?.result)) {
      posts = (result[0] as { result: Post[] }).result;
    }

    const enrichedPosts = await Promise.all(
      posts.map(async (post) => {
        try {
          console.log(`Fetching user for author ID: ${post.author}`);
          const clerk = await clerkClient();
          const clerkUser = await clerk.users.getUser(post.author);
          // اولویت با اسم، اگه نبود ایمیل
          const authorName =
            clerkUser.firstName || clerkUser.fullName || clerkUser.emailAddresses[0]?.emailAddress || 'ایمیل نامشخص';
          console.log(`Author name: ${authorName}`);
          return { ...post, authorName };
        } catch (error: any) {
          console.error(`Error fetching user ${post.author}:`, error.message);
          return { ...post, authorName: 'ایمیل نامشخص' };
        }
      })
    );

    console.log(`Fetched ${enrichedPosts.length} user posts`);
    return NextResponse.json(enrichedPosts, { status: 200 });
  } catch (error: any) {
    console.error('FETCH USER POSTS ERROR =>', error.message);
    return NextResponse.json(
      { error: 'خطا در دریافت پست‌ها', details: error.message },
      { status: 500 }
    );
  }
}

app\components\Footer.tsx
"use client";

import React, { useState, FormEvent } from "react";
import { motion } from "framer-motion";
import Link from "next/link";
import { FaTwitter, FaGithub, FaLinkedin, FaInstagram } from "react-icons/fa";

// Interface for contact form data
interface ContactForm {
  email: string;
  message: string;
}

const Footer: React.FC = () => {
  const [formData, setFormData] = useState<ContactForm>({ email: "", message: "" });
  const [formStatus, setFormStatus] = useState<string>("");

  // Handle form submission
  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    try {
      // Integrate with SurrealDB here
      console.log("Form submitted:", formData);
      setFormStatus("Message sent successfully!");
      setFormData({ email: "", message: "" });
    } catch (error) {
      setFormStatus("Error sending message!");
    }
  };

  // Animation variants for icons
  const iconVariants = {
    hover: { scale: 1.2, rotate: 10, transition: { duration: 0.3 } },
  };

  return (
    <footer className="blog-footer-container">
      <div className="blog-footer-content">
        {/* Logo and Description */}
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5 }}
          className="blog-footer-brand"
        >
          <h2 className="blog-footer-logo">Blog Platform</h2>
          <p className="blog-footer-description">
            A platform to share your stories and ideas with the world.
          </p>
        </motion.div>

        {/* Navigation Links */}
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5, delay: 0.1 }}
          className="blog-footer-links"
        >
          <h3 className="blog-footer-links-title">Useful Links</h3>
          <ul className="blog-footer-links-list">
            <li>
              <Link href="/about" className="blog-footer-link">
                About Us
              </Link>
            </li>
            <li>
              <Link href="/blogs" className="blog-footer-link">
                Blogs
              </Link>
            </li>
            <li>
              <Link href="/contact" className="blog-footer-link">
                Contact
              </Link>
            </li>
            <li>
              <Link href="/privacy" className="blog-footer-link">
                Privacy Policy
              </Link>
            </li>
          </ul>
        </motion.div>

        {/* Contact Form */}
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5, delay: 0.2 }}
          className="blog-footer-contact"
        >
          <h3 className="blog-footer-contact-title">Quick Contact</h3>
          <form onSubmit={handleSubmit} className="blog-footer-form">
            <input
              type="email"
              placeholder="Your Email"
              value={formData.email}
              onChange={(e) => setFormData({ ...formData, email: e.target.value })}
              className="blog-footer-input"
              required
              aria-label="Email address"
            />
            <textarea
              placeholder="Your Message"
              value={formData.message}
              onChange={(e) => setFormData({ ...formData, message: e.target.value })}
              className="blog-footer-textarea"
              rows={3}
              required
              aria-label="Message"
            />
            <button type="submit" className="blog-footer-button">
              Send
            </button>
            {formStatus && <p className="blog-footer-form-status">{formStatus}</p>}
          </form>
        </motion.div>

        {/* Social Media */}
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5, delay: 0.3 }}
          className="blog-footer-social"
        >
          <h3 className="blog-footer-social-title">Follow Us</h3>
          <div className="blog-footer-social-icons">
            <motion.a
              href="https://twitter.com"
              target="_blank"
              rel="noopener noreferrer"
              variants={iconVariants}
              whileHover="hover"
              className="blog-footer-social-icon"
            >
              <FaTwitter />
            </motion.a>
            <motion.a
              href="https://github.com"
              target="_blank"
              rel="noopener noreferrer"
              variants={iconVariants}
              whileHover="hover"
              className="blog-footer-social-icon"
            >
              <FaGithub />
            </motion.a>
            <motion.a
              href="https://linkedin.com"
              target="_blank"
              rel="noopener noreferrer"
              variants={iconVariants}
              whileHover="hover"
              className="blog-footer-social-icon"
            >
              <FaLinkedin />
            </motion.a>
            <motion.a
              href="https://instagram.com"
              target="_blank"
              rel="noopener noreferrer"
              variants={iconVariants}
              whileHover="hover"
              className="blog-footer-social-icon"
            >
              <FaInstagram />
            </motion.a>
          </div>
        </motion.div>
      </div>

      {/* Copyright */}
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        transition={{ duration: 0.5, delay: 0.4 }}
        className="blog-footer-copyright"
      >
        <p>© {new Date().getFullYear()} Blog Platform. All rights reserved.</p>
      </motion.div>
    </footer>
  );
};

export default Footer;

app\components\RecentPosts.tsx
'use client'

import { useState, useEffect } from 'react'
import { useUser } from '@clerk/nextjs'
import { useRouter } from 'next/navigation'
import Link from 'next/link'
import { Heart, Star } from 'lucide-react'

type Post = {
  id: string
  title: string
  content: string
  author: string
  created_at: string
  imageUrl?: string
  authorName: string
  updated_at?: string
}

type LikeStatus = {
  likesCount: number
  userLiked: boolean
}

type FavoriteStatus = {
  favoritesCount: number
  userFavorited: boolean
}

export default function RecentPosts() {
  const [posts, setPosts] = useState<Post[]>([])
  const [error, setError] = useState<string | null>(null)
  const [likeStatuses, setLikeStatuses] = useState<{ [key: string]: LikeStatus }>({})
  const [favoriteStatuses, setFavoriteStatuses] = useState<{ [key: string]: FavoriteStatus }>({})
  const { user } = useUser()
  const router = useRouter()

  useEffect(() => {
    async function fetchRecentPosts() {
      try {
        const url = '/api/posts?limit=4'
        console.log(`Fetching recent posts from: ${url}`)
        const response = await fetch(url)
        if (!response.ok) {
          const errorData = await response.json()
          throw new Error(errorData.error || 'Error fetching recent posts')
        }

        const fetchedPosts: Post[] = await response.json()
        console.log('Fetched recent posts:', fetchedPosts)
        setPosts(fetchedPosts)
        setError(null)

        // Fetch like and favorite status for each post
        const likeStatuses: { [key: string]: LikeStatus } = {}
        const favoriteStatuses: { [key: string]: FavoriteStatus } = {}
        await Promise.all(
          fetchedPosts.map(async (post: Post) => {
            const postId = post.id.split(':')[1]
            // Fetch likes
            const likeRes = await fetch(`/api/likes/${postId}`)
            if (likeRes.ok) {
              likeStatuses[post.id] = await likeRes.json()
            }
            // Fetch favorites
            const favoriteRes = await fetch(`/api/favorites/${postId}`)
            if (likeRes.ok) {
              favoriteStatuses[post.id] = await favoriteRes.json()
            }
          })
        )
        console.log('Like statuses:', likeStatuses)
        console.log('Favorite statuses:', favoriteStatuses)
        setLikeStatuses(likeStatuses)
        setFavoriteStatuses(favoriteStatuses)
      } catch (err: any) {
        console.error(`Fetch recent posts error: ${err.message}`)
        setError(err.message || 'Error fetching recent posts')
      }
    }

    fetchRecentPosts()
  }, [user])

  const handleDelete = async (id: string) => {
    try {
      if (!user) {
        setError('Please sign in to delete a post')
        return
      }

      const postId = id.split(':')[1]
      console.log(`Sending DELETE request for post: ${postId}`)

      const response = await fetch(`/api/posts/${postId}/delete`, {
        method: 'DELETE',
      })
      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || 'Error deleting post')
      }

      const result = await response.json()
      console.log('DELETE RESPONSE =>', result)

      setPosts(posts.filter((post) => post.id !== id))
      setError(null)
    } catch (err: any) {
      console.error(`Delete error: ${err.message}`)
      setError(err.message || 'Error deleting post')
    }
  }

  const handleLike = async (postId: string) => {
    if (!user) {
      setError('Please sign in to like a post')
      return
    }

    try {
      const response = await fetch(`/api/likes/${postId.split(':')[1]}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || 'Error liking post')
      }

      const { liked } = await response.json()
      setLikeStatuses((prev) => ({
        ...prev,
        [postId]: {
          likesCount: liked
            ? prev[postId].likesCount + 1
            : prev[postId].likesCount - 1,
          userLiked: liked,
        },
      }))
      setError(null)
    } catch (err: any) {
      console.error(`Like error: ${err.message}`)
      setError(err.message || 'Error liking post')
    }
  }

  const handleFavorite = async (postId: string) => {
    if (!user) {
      setError('Please sign in to add to favorites')
      return
    }

    try {
      const response = await fetch(`/api/favorites/${postId.split(':')[1]}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || 'Error adding to favorites')
      }

      const { favorited } = await response.json()
      setFavoriteStatuses((prev) => ({
        ...prev,
        [postId]: {
          favoritesCount: favorited
            ? prev[postId].favoritesCount + 1
            : prev[postId].favoritesCount - 1,
          userFavorited: favorited,
        },
      }))
      setError(null)
    } catch (err: any) {
      console.error(`Favorite error: ${err.message}`)
      setError(err.message || 'Error adding to favorites')
    }
  }

  // Function to truncate content
  const truncateContent = (content: string, maxLength: number = 100) => {
    if (content.length <= maxLength) return content
    return content.slice(0, maxLength) + '...'
  }

  return (
    <div>
      <h3 style={{ fontSize: '1.5rem', fontWeight: 600, marginBottom: '16px' }}>
        Recent Posts
      </h3>
      {error && (
        <p className="recent-post-error" style={{ marginBottom: '16px' }}>
          {error}
        </p>
      )}
      {posts.length === 0 && !error ? (
        <p style={{ color: '#4b5563' }}>No Recent Posts Found</p>
      ) : (
        <div className="recent-post-grid">
          {posts.map((post) => (
            <div key={post.id} className="recent-post-card">
              <Link href={`/posts/${post.id.split(':')[1]}`} className="recent-post-link">
                {post.imageUrl && (
                  <img src={post.imageUrl} alt={post.title} className="recent-post-img" />
                )}
                <h4 className="recent-post-title">{post.title}</h4>
                <p className="recent-post-content">{truncateContent(post.content)}</p>
              </Link>
              <p className="recent-post-meta">
                Author:{' '}
                <Link href={`/profile/${post.author}`} className="recent-post-author-link">
                  {post.authorName}
                </Link>
              </p>
              <p className="recent-post-meta">
                Posted: {new Date(post.created_at).toLocaleDateString('en-US')}
              </p>
              <div className="recent-post-actions">
                <div className="recent-post-like">
                  <button
                    onClick={() => handleLike(post.id)}
                    className={`recent-post-like-btn ${likeStatuses[post.id]?.userLiked ? 'liked' : ''}`}
                    disabled={!user}
                    data-tooltip="Like"
                  >
                    <Heart
                      size={16}
                      fill={likeStatuses[post.id]?.userLiked ? '#dc2626' : 'none'}
                      color={likeStatuses[post.id]?.userLiked ? '#dc2626' : '#4b5563'}
                    />
                  </button>
                  <span className="recent-post-like-count">{likeStatuses[post.id]?.likesCount || 0}</span>
                </div>
                <div className="recent-post-favorite">
                  <button
                    onClick={() => handleFavorite(post.id)}
                    className={`recent-post-favorite-btn ${favoriteStatuses[post.id]?.userFavorited ? 'favorited' : ''}`}
                    disabled={!user}
                    data-tooltip="Favorite"
                  >
                    <Star
                      size={16}
                      fill={favoriteStatuses[post.id]?.userFavorited ? '#eab308' : 'none'}
                      color={favoriteStatuses[post.id]?.userFavorited ? '#eab308' : '#4b5563'}
                    />
                  </button>
                  <span className="recent-post-favorite-count">{favoriteStatuses[post.id]?.favoritesCount || 0}</span>
                </div>
              </div>
              {user && (
                <div className="recent-post-controls">
                  {post.author === user.id && (
                    <button
                      className="recent-post-edit-btn"
                      onClick={() => router.push(`/edit-post/${post.id.split(':')[1]}`)}
                    >
                      Edit
                    </button>
                  )}
                  {(post.author === user.id ||
                    (user.publicMetadata?.role === 'admin')) && (
                    <button className="recent-post-delete-btn" onClick={() => handleDelete(post.id)}>
                      Delete
                    </button>
                  )}
                </div>
              )}
            </div>
          ))}
        </div>
      )}
    </div>
  )
}

app\components\ThemeProvider.tsx
'use client'

import { createContext, useContext, useEffect, useState } from 'react'

type Theme = 'light' | 'dark'

interface ThemeContextType {
  theme: Theme
  toggleTheme: () => void
}

const ThemeContext = createContext<ThemeContextType | undefined>(undefined)

export function ThemeProvider({ children }: { children: React.ReactNode }) {
  const [theme, setTheme] = useState<Theme>('light')

  // Load theme from localStorage on mount
  useEffect(() => {
    const savedTheme = localStorage.getItem('theme') as Theme | null
    if (savedTheme) {
      setTheme(savedTheme)
      if (savedTheme === 'dark') {
        document.documentElement.classList.add('dark')
      }
    }
  }, [])

  // Toggle theme and update localStorage
  const toggleTheme = () => {
    const newTheme = theme === 'light' ? 'dark' : 'light'
    setTheme(newTheme)
    if (newTheme === 'dark') {
      document.documentElement.classList.add('dark')
    } else {
      document.documentElement.classList.remove('dark')
    }
    localStorage.setItem('theme', newTheme)
  }

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  )
}

// Hook to use theme context
export function useTheme() {
  const context = useContext(ThemeContext)
  if (!context) {
    throw new Error('useTheme must be used within a ThemeProvider')
  }
  return context
}

app\components\TopPosts.tsx
'use client'

import { useState, useEffect } from 'react'
import { useUser } from '@clerk/nextjs'
import { useRouter } from 'next/navigation'
import Link from 'next/link'
import { Heart, Star } from 'lucide-react'

type Post = {
  id: string
  title: string
  content: string
  author: string
  created_at: string
  imageUrl?: string
  authorName: string
  updated_at?: string
  likesCount: number
}

type LikeStatus = {
  likesCount: number
  userLiked: boolean
}

type FavoriteStatus = {
  favoritesCount: number
  userFavorited: boolean
}

export default function TopPosts() {
  const [posts, setPosts] = useState<Post[]>([])
  const [error, setError] = useState<string | null>(null)
  const [likeStatuses, setLikeStatuses] = useState<{ [key: string]: LikeStatus }>({})
  const [favoriteStatuses, setFavoriteStatuses] = useState<{ [key: string]: FavoriteStatus }>({})
  const { user } = useUser()
  const router = useRouter()

  const truncateContent = (content: string, maxLength: number = 100) => {
    if (content.length <= maxLength) return content
    return content.slice(0, maxLength) + '...'
  }

  const getRankLabel = (index: number) => {
    switch (index) {
      case 0:
        return 'برترین پست'
      case 1:
        return 'پست دوم'
      case 2:
        return 'پست سوم'
      default:
        return ''
    }
  }

  useEffect(() => {
    let isMounted = true

    async function fetchTopPosts() {
      try {
        console.log('[TOP_POSTS_CLIENT] Fetching top posts from: /api/posts/top')
        const response = await fetch('/api/posts/top', { cache: 'no-store' })
        console.log('[TOP_POSTS_CLIENT] Response status:', response.status)
        const responseText = await response.text()
        console.log('[TOP_POSTS_CLIENT] Raw response:', responseText)

        let fetchedPosts: Post[]
        try {
          fetchedPosts = JSON.parse(responseText)
        } catch (parseError) {
          console.error('[TOP_POSTS_CLIENT] JSON parse error:', parseError)
          throw new Error('Invalid response format from API')
        }

        if (!response.ok) {
          console.error('[TOP_POSTS_CLIENT] Error response:', fetchedPosts)
          throw new Error(fetchedPosts.error || 'Error fetching top posts')
        }

        if (!isMounted) return

        console.log('[TOP_POSTS_CLIENT] Fetched posts:', JSON.stringify(fetchedPosts, null, 2))
        setPosts(fetchedPosts)
        setError(null)

        if (fetchedPosts.length === 0) {
          console.log('[TOP_POSTS_CLIENT] No posts returned from API')
          return
        }

        const likeStatuses: { [key: string]: LikeStatus } = {}
        const favoriteStatuses: { [key: string]: FavoriteStatus } = {}
        await Promise.all(
          fetchedPosts.map(async (post: Post) => {
            const postId = post.id.split(':')[1]
            try {
              console.log(`[TOP_POSTS_CLIENT] Fetching likes for post: ${postId}`)
              const likeRes = await fetch(`/api/likes/${postId}`, { cache: 'no-store' })
              if (likeRes.ok) {
                const likeData = await likeRes.json()
                likeStatuses[post.id] = {
                  likesCount: likeData.likesCount || 0,
                  userLiked: likeData.userLiked,
                }
              }
            } catch (err) {
              console.error(`[TOP_POSTS_CLIENT] Error fetching likes for ${postId}:`, err)
            }

            try {
              console.log(`[TOP_POSTS_CLIENT] Fetching favorites for post: ${postId}`)
              const favoriteRes = await fetch(`/api/favorites/${postId}`, { cache: 'no-store' })
              if (favoriteRes.ok) {
                favoriteStatuses[post.id] = await favoriteRes.json()
              }
            } catch (err) {
              console.error(`[TOP_POSTS_CLIENT] Error fetching favorites for ${postId}:`, err)
            }
          })
        )

        if (!isMounted) return

        console.log('[TOP_POSTS_CLIENT] Like statuses:', JSON.stringify(likeStatuses, null, 2))
        console.log('[TOP_POSTS_CLIENT] Favorite statuses:', JSON.stringify(favoriteStatuses, null, 2))
        setLikeStatuses(likeStatuses)
        setFavoriteStatuses(favoriteStatuses)
      } catch (err: any) {
        if (!isMounted) return
        console.error('[TOP_POSTS_CLIENT] Fetch top posts error:', err.message)
        setError(err.message || 'Error to Catch Top Post`s')
      }
    }

    console.log('[TOP_POSTS_CLIENT] Triggering fetchTopPosts')
    fetchTopPosts()

    return () => {
      isMounted = false
    }
  }, [user])

  const handleDelete = async (id: string) => {
    try {
      if (!user) {
        setError('لطفاً برای حذف پست وارد شوید')
        return
      }

      const postId = id.split(':')[1]
      console.log(`[TOP_POSTS_CLIENT] Sending DELETE request for post: ${postId}`)
      const response = await fetch(`/api/posts/${postId}/delete`, {
        method: 'DELETE',
      })
      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || 'Error deleting post')
      }

      console.log('[TOP_POSTS_CLIENT] DELETE RESPONSE:', await response.json())
      setPosts(posts.filter((post) => post.id !== id))
      setError(null)
    } catch (err: any) {
      console.error('[TOP_POSTS_CLIENT] Delete error:', err.message)
      setError(err.message || 'خطا در حذف پست')
    }
  }

  const handleLike = async (postId: string) => {
    if (!user) {
      setError('لطفاً برای لایک کردن وارد شوید')
      return
    }

    try {
      console.log(`[TOP_POSTS_CLIENT] Sending LIKE request for post: ${postId}`)
      const response = await fetch(`/api/likes/${postId.split(':')[1]}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || 'Error liking post')
      }

      const { liked } = await response.json()
      setLikeStatuses((prev) => ({
        ...prev,
        [postId]: {
          likesCount: liked
            ? prev[postId].likesCount + 1
            : prev[postId].likesCount - 1,
          userLiked: liked,
        },
      }))
      await fetchTopPosts()
      setError(null)
    } catch (err: any) {
      setError(err.message || 'خطا در لایک کردن پست')
    }
  }

  const handleFavorite = async (postId: string) => {
    if (!user) {
      setError('لطفاً برای افزودن به علاقه‌مندی‌ها وارد شوید')
      return
    }

    try {
      console.log(`[TOP_POSTS_CLIENT] Sending FAVORITE request for post: ${postId}`)
      const response = await fetch(`/api/favorites/${postId.split(':')[1]}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || 'Error adding to favorites')
      }

      const { favorited } = await response.json()
      setFavoriteStatuses((prev) => ({
        ...prev,
        [postId]: {
          favoritesCount: favorited
            ? prev[postId].favoritesCount + 1
            : prev[postId].favoritesCount - 1,
          userFavorited: favorited,
        },
      }))
      setError(null)
    } catch (err: any) {
      console.error('[TOP_POSTS_CLIENT] Favorite error:', err.message)
      setError(err.message || 'خطا در افزودن به علاقه‌مندی‌ها')
    }
  }

  return (
    <div>
      <h3 style={{ fontSize: '1.5rem', fontWeight: 600, marginBottom: '16px' }}>
        Top Post`s
      </h3>
      {error && (
        <p className="top-post-error" style={{ marginBottom: '16px' }}>
          {error}
        </p>
      )}
      {posts.length === 0 && !error ? (
        <p style={{ color: '#4b5563' }}>
         There is no Top Posts
        </p>
      ) : (
        <div className="top-post-grid">
          {posts.map((post, index) => (
            <div key={post.id} className="top-post-card">
              <Link href={`/posts/${post.id.split(':')[1]}`} className="top-post-link">
                <span className="top-post-rank">{getRankLabel(index)}</span>
                {post.imageUrl && <img src={post.imageUrl} alt={post.title} className="top-post-img" />}
                <h4 className="top-post-title">{post.title}</h4>
                <p className="top-post-content">{truncateContent(post.content)}</p>
              </Link>
              <p className="top-post-meta">
                Author:{' '}
                <Link href={`/profile/${post.author}`} className="top-post-author-link">
                  {post.authorName}
                </Link>
              </p>
              <p className="top-post-meta">
Post Date: {new Date(post.created_at).toLocaleDateString('en-US')}
              </p>
              {post.updated_at && (
                <p className="top-post-meta">
                  به‌روزرسانی: {new Date(post.updated_at).toLocaleDateString('en-US')}
                </p>
              )}
              <p className="top-post-meta">تعداد لایک‌ها: {likeStatuses[post.id]?.likesCount || 0}</p>
              <div className="top-post-actions">
                <div className="top-post-like">
                  <button
                    onClick={() => handleLike(post.id)}
                    className={`top-post-like-btn ${likeStatuses[post.id]?.userLiked ? 'liked' : ''}`}
                    disabled={!user}
                    data-tooltip="لایک"
                  >
                    <Heart
                      size={16}
                      fill={likeStatuses[post.id]?.userLiked ? '#dc2626' : 'none'}
                      color={likeStatuses[post.id]?.userLiked ? '#dc2626' : '#4b5563'}
                    />
                  </button>
                  <span className="top-post-like-count">{likeStatuses[post.id]?.likesCount || 0}</span>
                </div>
                <div className="top-post-favorite">
                  <button
                    onClick={() => handleFavorite(post.id)}
                    className={`top-post-favorite-btn ${favoriteStatuses[post.id]?.userFavorited ? 'favorited' : ''}`}
                    disabled={!user}
                    data-tooltip="علاقه‌مندی"
                  >
                    <Star
                      size={16}
                      fill={favoriteStatuses[post.id]?.userFavorited ? '#eab308' : 'none'}
                      color={favoriteStatuses[post.id]?.userFavorited ? '#eab308' : '#4b5563'}
                    />
                  </button>
                  <span className="top-post-favorite-count">{favoriteStatuses[post.id]?.favoritesCount || 0}</span>
                </div>
              </div>
              {user && (
                <div className="top-post-controls">
                  {post.author === user.id && (
                    <button
                      className="top-post-edit-btn"
                      onClick={() => router.push(`/edit-post/${post.id.split(':')[1]}`)}
                    >
                      ویرایش
                    </button>
                  )}
                  {(post.author === user.id || (user.publicMetadata?.role === 'admin')) && (
                    <button className="top-post-delete-btn" onClick={() => handleDelete(post.id)}>
                      حذف
                    </button>
                  )}
                </div>
              )}
            </div>
          ))}
        </div>
      )}
    </div>
  )
}

app\create-post\page.tsx
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";

export default function CreatePost() {
  const [title, setTitle] = useState("");
  const [content, setContent] = useState("");
  const [image, setImage] = useState<File | null>(null);
  const [imageUrl, setImageUrl] = useState("");
  const [uploading, setUploading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const router = useRouter();

  const handleImageChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      setImage(file);
      setUploading(true);

      const formData = new FormData();
      formData.append("image", file);

      try {
        const res = await fetch("/api/upload-image", {
          method: "POST",
          body: formData,
        });

        if (res.ok) {
          const data = await res.json();
          setImageUrl(data.url);
          setError(null);
        } else {
          setError("خطا در آپلود تصویر");
        }
      } catch (error) {
        setError("خطا در آپلود تصویر");
      } finally {
        setUploading(false);
      }
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    try {
      const res = await fetch("/api/posts", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ title, content, imageUrl }),
      });

      if (res.ok) {
        router.push("/");
      } else {
        const errorData = await res.json();
        setError(errorData.error || "خطا در ایجاد پست");
      }
    } catch (error) {
      setError("خطا در ایجاد پست");
    }
  };

  return (
    <div className="create-post">
      <h3> Create New Post </h3>
      {error && <p className="error">{error}</p>}
      <form onSubmit={handleSubmit}>
        <div className="form-group">
          <label htmlFor="title">Title</label>
          <input
            type="text"
            id="title"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            required
          />
        </div>
        <div className="form-group">
          <label htmlFor="نظر">Content</label>
          <textarea
            id="content"
            value={content}
            onChange={(e) => setContent(e.target.value)}
            required
          />
        </div>
        <div className="form-group">
          <label htmlFor="image">Picture</label>
          <input
            type="file"
            id="image"
            accept="image/*"
            onChange={handleImageChange}
            disabled={uploading}
          />
          {uploading && <p className="uploading-text"> Uploading...</p>}
          {imageUrl && (
            <img src={imageUrl} alt="Prev" className="image-preview" />
          )}
        </div>
        <button type="submit" className="submit-button" disabled={uploading}>
          ایجاد پست
        </button>
      </form>
    </div>
  );
}

app\edit-post\[id]\page.tsx
// فایل: app/edit-post/[id]/page.tsx
'use client';

import { useState, useEffect } from 'react';
import { useRouter, useParams } from 'next/navigation';
import { useUser } from '@clerk/nextjs';

type Post = {
  id: string;
  title: string;
  content: string;
  author: string;
  created_at: string;
  imageUrl?: string;
};

export default function EditPost() {
  const [title, setTitle] = useState('');
  const [content, setContent] = useState('');
  const [image, setImage] = useState<File | null>(null);
  const [imageUrl, setImageUrl] = useState<string | null>(null);
  const [uploading, setUploading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const router = useRouter();
  const { id } = useParams();
  const { user } = useUser();

  useEffect(() => {
    async function fetchPost() {
      try {
        if (!user || !id) return;

        const response = await fetch(`/api/posts/${id}`);
        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          throw new Error(errorData.error || 'Failed to fetch post');
        }

        const post: Post = await response.json();
        setTitle(post.title);
        setContent(post.content);
        setImageUrl(post.imageUrl || null);
        setError(null);
      } catch (err: any) {
        setError(err.message || 'Failed to fetch post');
      }
    }

    fetchPost();
  }, [user, id]);

  const handleImageChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      setImage(file);
      setUploading(true);

      const formData = new FormData();
      formData.append('image', file);

      try {
        const res = await fetch('/api/upload-image', {
          method: 'POST',
          body: formData,
        });

        if (res.ok) {
          const data = await res.json();
          setImageUrl(data.url);
          setError(null);
        } else {
          setError('خطا در آپلود تصویر');
        }
      } catch (error) {
        setError('خطا در آپلود تصویر');
      } finally {
        setUploading(false);
      }
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    try {
      const res = await fetch(`/api/posts/${id}/update`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          title,
          content,
          imageUrl: imageUrl || undefined,
        }),
      });

      if (res.ok) {
        router.push('/');
      } else {
        const errorData = await res.json();
        setError(errorData.error || 'خطا در به‌روزرسانی پست');
      }
    } catch (error) {
      setError('خطا در به‌روزرسانی پست');
    }
  };

  return (
    <div style={{ maxWidth: '800px', margin: '0 auto', padding: '16px' }}>
      <h3 style={{ fontSize: '1.5rem', fontWeight: '600', marginBottom: '16px' }}>
        ویرایش پست
      </h3>
      {error && (
        <p style={{ color: '#dc2626', marginBottom: '16px' }}>{error}</p>
      )}
      <form onSubmit={handleSubmit}>
        <div style={{ marginBottom: '16px' }}>
          <label
            htmlFor="title"
            style={{ display: 'block', fontWeight: 'bold', marginBottom: '8px' }}
          >
            عنوان
          </label>
          <input
            type="text"
            id="title"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            style={{
              width: '100%',
              padding: '8px',
              border: '1px solid #d1d5db',
              borderRadius: '4px',
            }}
            required
          />
        </div>
        <div style={{ marginBottom: '16px' }}>
          <label
            htmlFor="content"
            style={{ display: 'block', fontWeight: 'bold', marginBottom: '8px' }}
          >
            محتوا
          </label>
          <textarea
            id="content"
            value={content}
            onChange={(e) => setContent(e.target.value)}
            style={{
              width: '100%',
              padding: '8px',
              border: '1px solid #d1d5db',
              borderRadius: '4px',
              minHeight: '120px',
            }}
            required
          />
        </div>
        <div style={{ marginBottom: '16px' }}>
          <label
            htmlFor="image"
            style={{ display: 'block', fontWeight: 'bold', marginBottom: '8px' }}
          >
            تصویر
          </label>
          <input
            type="file"
            id="image"
            accept="image/*"
            onChange={handleImageChange}
            disabled={uploading}
            style={{ display: 'block' }}
          />
          {uploading && (
            <p style={{ color: '#4b5563', marginTop: '8px' }}>Uploading...</p>
          )}
          {imageUrl && (
            <img
              src={imageUrl}
              alt="Preview"
              style={{ marginTop: '8px', maxWidth: '100%', height: 'auto' }}
            />
          )}
        </div>
        <button
          type="submit"
          disabled={uploading} // فقط وقتی در حال آپلود است غیرفعال می‌شود
          style={{
            backgroundColor: uploading ? '#d1d5db' : '#2563eb',
            color: 'white',
            padding: '8px 16px',
            borderRadius: '4px',
            border: 'none',
            cursor: uploading ? 'not-allowed' : 'pointer',
          }}
        >
          Update
        </button>
      </form>
    </div>
  );
}

app\favorites\page.tsx
'use client'

import { useState, useEffect } from 'react';
import { useUser } from '@clerk/nextjs';
import PostList from '@/components/PostList';
import SearchBox from '@/components/SearchBox';

export default function FavoritesPage({ searchParams }: { searchParams: { q?: string } }) {
  const searchQuery = searchParams.q || '';
  const { user, isSignedIn } = useUser();
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!isSignedIn) {
      setError('Please sign in to view your favorites');
    } else {
      setError(null);
    }
  }, [isSignedIn]);

  return (
    <div className="container">
      <h2 style={{ fontSize: '1.75rem', fontWeight: 600, marginBottom: '16px' }}>
        Your Favorite Posts
      </h2>
      <p style={{ marginBottom: '16px', color: '#4b5563' }}>
        View all posts you’ve added to your favorites.
      </p>
      <SearchBox defaultValue={searchQuery} formAction="/favorites" />
      {error ? (
        <p className="error" style={{ marginBottom: '16px' }}>
          {error}
        </p>
      ) : (
        <PostList searchQuery={searchQuery} isFavorites={true} />
      )}
    </div>
  );
}

app\globals.css
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');

:root {
  --background-color: #f8fafc;
  --text-color: #1f2937;
  --card-background: #ffffff;
  --card-border: #e5e7eb;
  --card-shadow: rgba(0, 0, 0, 0.1);
  --meta-color: #6b7280;
  --link-color: #2563eb;
  --error-color: #dc2626;
  --like-color: #dc2626;
  --favorite-color: #eab308;
  --button-bg: #2563eb;
  --button-hover-bg: #1d4ed8;
  --delete-bg: #dc2626;
  --delete-hover-bg: #dc2626;
  --nav-background: #ffffff;
  --nav-text: #4b5563;
  --hover-bg: #f3f4f6;
}

.dark {
  --background-color: #1e293b;
  --text-color: #e2e8f0;
  --card-background: #334155;
  --card-border: #475569;
  --card-shadow: rgba(0, 0, 0, 0.2);
  --meta-color: #94a3b8;
  --link-color: #60a5fa;
  --error-color: #f87171;
  --like-color: #f87171;
  --favorite-color: #facc15;
  --button-bg: #60a5fa;
  --button-hover-bg: #3b82f6;
  --delete-bg: #f87171;
  --delete-hover-bg: #ef4444;
  --nav-background: #334155;
  --nav-text: #e2e8f0;
  --hover-bg: #475569;
}

* {
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Inter', sans-serif;
  background-color: var(--background-color);
  color: var(--text-color);
  line-height: 1.6;
  min-height: 100vh;
}

.container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 16px;
}

h2, h3, p {
  margin-bottom: 10px;
}

.comment-section {
  max-width: 800px;
  margin: 30px auto 0;
  padding: 20px;
}

.post {
  background-color: var(--card-background);
  border: 1px solid var(--card-border);
  border-radius: 8px;
  padding: 16px;
  margin-bottom: 16px;
}

.post h4 {
  font-size: 18px;
  font-weight: 600;
  margin-bottom: 8px;
  color: var(--text-color);
}

.post p {
  font-size: 16px;
  color: var(--meta-color);
  margin-bottom: 8px;
}

.post-content {
  color: var(--meta-color);
  margin-bottom: 8px;
  white-space: pre-wrap;
}

.post-image {
  max-width: 100%;
  height: auto;
  border-radius: 6px;
  margin-bottom: 16px;
}

.meta {
  color: var(--meta-color);
  font-size: 14px;
}

.author-link {
  color: var(--link-color);
  text-decoration: none;
}

.author-link:hover {
  text-decoration: underline;
}

.like-favorite-section {
  display: flex;
  gap: 16px;
  margin-top: 8px;
  justify-content: flex-end;
}

.like-section, .favorite-section {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-top: 8px;
  position: relative;
}

.like-button, .favorite-button {
  background: none;
  border: none;
  cursor: pointer;
  padding: 4px;
  display: flex;
  align-items: center;
}

.like-button:disabled, .favorite-button:disabled {
  cursor: not-allowed;
  opacity: 0.5;
}

.like-button.liked {
  color: var(--like-color);
}

.favorite-button.favorited {
  color: var(--favorite-color);
}

.like-count, .favorite-count {
  font-size: 14px;
  color: var(--meta-color);
}

.like-button[data-tooltip], .favorite-button[data-tooltip] {
  position: relative;
}

.like-button[data-tooltip]::before, .favorite-button[data-tooltip]::before {
  content: attr(data-tooltip);
  position: absolute;
  top: -30px;
  left: 50%;
  transform: translateX(-50%);
  background-color: var(--nav-background);
  color: var(--nav-text);
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 12px;
  white-space: nowrap;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.2s, visibility 0.2s;
}

.like-button[data-tooltip]:hover::before, .favorite-button[data-tooltip]:hover::before {
  opacity: 1;
  visibility: visible;
}

.actions {
  display: flex;
  gap: 8px;
  margin-top: 8px;
}

.edit, .delete {
  padding: 8px 16px;
  border-radius: 4px;
  cursor: pointer;
  color: #ffffff;
  border: none;
}

.edit {
  background-color: var(--button-bg);
}

.delete {
  background-color: var(--delete-bg);
}

.error {
  color: var(--error-color);
  font-size: 0.9em;
  margin-bottom: 8px;
  font-weight: 500;
}

.recent-post-grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 16px;
  margin-bottom: 16px;
}

.recent-post-card {
  border: 1px solid var(--card-border);
  border-radius: 8px;
  padding: 12px;
  background: var(--card-background);
  box-shadow: 0 1px 3px var(--card-shadow);
  transition: transform 0.2s;
}

.recent-post-card:hover {
  transform: translateY(-2px);
}

.recent-post-link {
  text-decoration: none;
  color: inherit;
  display: block;
}

.recent-post-img {
  max-width: 100%;
  max-height: 120px;
  object-fit: cover;
  border-radius: 6px;
  margin-bottom: 8px;
}

.recent-post-title {
  font-size: 1rem;
  font-weight: 600;
  margin: 0 0 8px;
  color: var(--text-color);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.recent-post-content {
  font-size: 0.875rem;
  color: var(--meta-color);
  margin-bottom: 8px;
  line-height: 1.4;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

.recent-post-meta {
  font-size: 0.75rem;
  color: var(--meta-color);
  margin-bottom: 4px;
}

.recent-post-author-link {
  color: var(--link-color);
  text-decoration: none;
}

.recent-post-author-link:hover {
  text-decoration: underline;
}

.recent-post-actions {
  display: flex;
  gap: 12px;
  margin-top: 8px;
}

.recent-post-like, .recent-post-favorite {
  display: flex;
  align-items: center;
  gap: 4px;
}

.recent-post-like-btn, .recent-post-favorite-btn {
  background: none;
  border: none;
  cursor: pointer;
  padding: 4px;
}

.recent-post-like-btn.liked {
  color: var(--like-color);
}

.recent-post-favorite-btn.favorited {
  color: var(--favorite-color);
}

.recent-post-like-count, .recent-post-favorite-count {
  font-size: 0.75rem;
  color: var(--meta-color);
}

.recent-post-controls {
  display: flex;
  gap: 8px;
  margin-top: 8px;
}

.recent-post-edit-btn, .recent-post-delete-btn {
  padding: 6px 12px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.75rem;
  border: none;
}

.recent-post-edit-btn {
  background-color: var(--button-bg);
  color: white;
}

.recent-post-delete-btn {
  background-color: var(--delete-bg);
  color: white;
}

.recent-post-error {
  color: var(--error-color);
  font-weight: 500;
}

.top-post-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 1.5rem;
  padding: 1rem 0;
}

.top-post-card {
  background: var(--card-background);
  border: 1px solid var(--card-border);
  border-radius: 0.5rem;
  padding: 1rem;
  box-shadow: 0 2px 4px var(--card-shadow);
  transition: transform 0.2s;
}

.top-post-card:hover {
  transform: translateY(-2px);
}

.top-post-link {
  text-decoration: none;
  color: inherit;
  display: block;
}

.top-post-img {
  width: 100%;
  height: 150px;
  object-fit: cover;
  border-radius: 0.5rem;
  margin-bottom: 0.75rem;
}

.top-post-title {
  font-size: 1.25rem;
  font-weight: 600;
  margin: 0.5rem 0;
  color: var(--text-color);
}

.top-post-content {
  font-size: 0.875rem;
  color: var(--meta-color);
  margin-bottom: 0.75rem;
}

.top-post-meta {
  font-size: 0.75rem;
  color: var(--meta-color);
  margin: 0.25rem 0;
}

.top-post-author-link {
  color: var(--link-color);
  text-decoration: none;
}

.top-post-author-link:hover {
  text-decoration: underline;
}

.top-post-actions {
  display: flex;
  gap: 1rem;
  margin-top: 0.5rem;
}

.top-post-like, .top-post-favorite {
  display: flex;
  align-items: center;
  gap: 0.25rem;
}

.top-post-like-btn, .top-post-favorite-btn {
  background: none;
  border: none;
  cursor: pointer;
  padding: 0.25rem;
  border-radius: 0.25rem;
}

.top-post-like-btn.liked {
  color: var(--like-color);
}

.top-post-favorite-btn.favorited {
  color: var(--favorite-color);
}

.top-post-like-btn:hover, .top-post-favorite-btn:hover {
  background: var(--hover-bg);
}

.top-post-like-count, .top-post-favorite-count {
  font-size: 0.75rem;
  color: var(--meta-color);
}

.top-post-controls {
  display: flex;
  gap: 0.5rem;
  margin-top: 0.5rem;
}

.top-post-edit-btn {
  background: var(--button-bg);
  color: white;
  border: none;
  padding: 0.25rem 0.5rem;
  border-radius: 0.25rem;
  cursor: pointer;
  font-size: 0.75rem;
}

.top-post-edit-btn:hover {
  background: var(--button-hover-bg);
}

.top-post-delete-btn {
  background: var(--delete-bg);
  color: white;
  border: none;
  padding: 0.25rem 0.5rem;
  border-radius: 0.25rem;
  cursor: pointer;
  font-size: 0.75rem;
}

.top-post-delete-btn:hover {
  background: var(--delete-hover-bg);
}

.top-post-error {
  color: var(--error-color);
  font-size: 0.875rem;
}

.top-post-rank {
  font-size: 0.85rem;
  padding: 0.2rem 0.4rem;
}

.comment-list {
  margin-top: 20px;
}

.comment {
  border: 1px solid var(--card-border);
  padding: 10px;
  margin-bottom: 10px;
  border-radius: 5px;
  background-color: var(--card-background);
}

.comment.reply {
  background-color: var(--hover-bg);
  border-left: 2px solid var(--link-color);
  padding-left: 10px;
}

.comment-date {
  font-size: 0.8em;
  color: var(--meta-color);
}

.comment button {
  background: none;
  border: none;
  color: var(--link-color);
  cursor: pointer;
  font-size: 0.9em;
}

.author-name {
  color: var(--link-color);
  cursor: pointer;
  font-weight: bold;
}

.author-name:hover {
  text-decoration: underline;
}

.comment-form {
  display: flex;
  flex-direction: column;
  gap: 10px;
  margin-bottom: 20px;
}

.comment-form textarea {
  width: 100%;
  min-height: 100px;
  padding: 10px;
  border: 1px solid var(--card-border);
  border-radius: 5px;
  margin-bottom: 10px;
  background-color: var(--card-background);
  color: var(--text-color);
}

.comment-form button {
  padding: 10px 16px;
  background-color: var(--button-bg);
  color: white;
  border: none;
  border-radius: 5px;
  cursor: pointer;
}

.comment-form button:hover {
  background-color: var(--button-hover-bg);
}

.comment-form button:disabled {
  background-color: #ccc;
  cursor: not-allowed;
}

nav {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  background-color: var(--nav-background);
  border-bottom: 1px solid var(--card-border);
  z-index: 1000;
}

nav .container {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px;
}

nav .logo {
  font-size: 1.5rem;
  font-weight: 600;
  color: var(--link-color);
  text-decoration: none;
}

nav .desktop-menu {
  display: flex;
  align-items: center;
  gap: 24px;
}

nav .desktop-menu a {
  color: var(--nav-text);
  text-decoration: none;
  font-size: 1rem;
  transition: color 0.2s;
}

nav .desktop-menu a:hover {
  color: var(--link-color);
}

nav .mobile-menu-button {
  display: none;
  background: none;
  border: none;
  cursor: pointer;
}

nav .mobile-menu {
  display: none;
  background-color: var(--nav-background);
  border-top: 1px solid var(--card-border);
  padding: 16px;
}

nav .mobile-menu.active {
  display: block;
}

nav .mobile-menu a {
  display: block;
  padding: 12px 0;
  color: var(--nav-text);
  text-decoration: none;
  font-size: 1rem;
}

nav .mobile-menu a:hover {
  color: var(--link-color);
}

.auth-buttons {
  display: flex;
  gap: 16px;
  align-items: center;
}

.clerk-button {
  padding: 8px 16px;
  border: none;
  border-radius: 6px;
  font-size: 0.9rem;
  cursor: pointer;
  transition: background-color 0.2s;
  color: #ffffff;
}

.clerk-button.sign-in, .clerk-button.create-post, .clerk-button.admin-panel {
  background-color: var(--button-bg);
}

.clerk-button.sign-in:hover, .clerk-button.create-post:hover, .clerk-button.admin-panel:hover {
  background-color: var(--button-hover-bg);
}

.clerk-button.sign-up {
  background-color: #10b981;
}

.clerk-button.sign-up:hover {
  background-color: #059669;
}

form {
  max-width: 600px;
}

form input, form textarea {
  width: 100%;
  padding: 12px;
  border: 1px solid var(--card-border);
  border-radius: 6px;
  font-size: 1rem;
  margin-bottom: 16px;
  background-color: var(--card-background);
  color: var(--text-color);
}

form input:focus, form textarea:focus {
  outline: none;
  border-color: var(--link-color);
  box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
}

form button {
  padding: 12px 24px;
  background-color: var(--button-bg);
  color: #ffffff;
  border: none;
  border-radius: 6px;
  font-size: 1rem;
  cursor: pointer;
  transition: background-color 0.2s;
}

form button:hover {
  background-color: var(--button-hover-bg);
}

.image-preview {
  margin: 16px 0;
}

.image-preview img {
  max-width: 200px;
  border-radius: 6px;
  margin-bottom: 12px;
}

.image-preview .remove-button {
  padding: 8px 16px;
  background-color: var(--delete-bg);
  color: #ffffff;
  border: none;
  border-radius: 6px;
  font-size: 0.9rem;
  cursor: pointer;
  transition: background-color 0.2s;
}

.image-preview .remove-button:hover {
  background-color: var(--delete-hover-bg);
}

.create-post {
  max-width: 500px;
  margin: 0 auto;
  padding: 20px;
}

.create-post h3 {
  font-size: 1.5rem;
  font-weight: 600;
  margin-bottom: 16px;
}

.form-group {
  margin-bottom: 15px;
}

.form-group label {
  display: block;
  font-size: 14px;
  font-weight: 500;
  margin-bottom: 5px;
}

.form-group input, .form-group textarea {
  width: 100%;
  padding: 8px;
  border: 1px solid var(--card-border);
  border-radius: 4px;
  font-size: 16px;
  background-color: var(--card-background);
  color: var(--text-color);
}

.form-group textarea {
  resize: vertical;
  min-height: 100px;
}

.form-group input[type='file'] {
  padding: 5px;
}

.uploading-text {
  color: var(--meta-color);
  font-size: 14px;
  margin-top: 5px;
}

.submit-button {
  background-color: var(--button-bg);
  color: white;
  padding: 10px 15px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 16px;
}

.submit-button:disabled {
  background-color: #cccccc;
  cursor: not-allowed;
}

.profile-title {
  font-size: 24px;
  font-weight: bold;
  margin-bottom: 16px;
}

.profile-info {
  margin-bottom: 24px;
  display: flex;
  align-items: center;
  gap: 16px;
}

.profile-image {
  width: 80px;
  height: 80px;
  border-radius: 50%;
  object-fit: cover;
}

.profile-info p {
  font-size: 18px;
  margin-bottom: 8px;
}

.profile-posts-title {
  font-size: 20px;
  font-weight: 600;
  margin-bottom: 16px;
}

.profile-error {
  color: var(--error-color);
  font-size: 18px;
}

.admin-title {
  font-size: 24px;
  font-weight: bold;
  margin-bottom: 16px;
}

.admin-error {
  color: var(--error-color);
  font-size: 18px;
  margin-bottom: 16px;
}

.edit-post-container {
  max-width: 800px;
  margin: 0 auto;
  padding: 16px;
}

.edit-post-title {
  font-size: 1.5rem;
  font-weight: bold;
  margin-bottom: 16px;
}

.edit-post-error {
  color: var(--error-color);
  margin-bottom: 16px;
}

.edit-post-form-group {
  margin-bottom: 16px;
}

.edit-post-label {
  display: block;
  margin-bottom: 8px;
}

.edit-post-input, .edit-post-textarea {
  width: 100%;
  padding: 8px;
  border: 1px solid var(--card-border);
  border-radius: 4px;
  background-color: var(--card-background);
  color: var(--text-color);
}

.edit-post-textarea {
  min-height: 120px;
}

.edit-post-image-preview {
  margin-top: 8px;
  max-width: 100%;
}

.edit-post-submit {
  background-color: var(--button-bg);
  color: white;
  padding: 8px 16px;
  border-radius: 4px;
  border: none;
  cursor: pointer;
}

.theme-toggle-btn {
  background: none;
  border: none;
  cursor: pointer;
  padding: 4px;
  border-radius: 50%;
  transition: background-color 0.3s;
}

.theme-toggle-btn:hover {
  background-color: var(--hover-bg);
}

.theme-toggle-icon {
  color: var(--nav-text);
}

@media (max-width: 1024px) {
  .recent-post-grid {
    grid-template-columns: repeat(2, 1fr);
  }
}

@media (max-width: 768px) {
  nav .desktop-menu {
    display: none;
  }

  nav .mobile-menu-button {
    display: block;
  }

  .post {
    padding: 16px;
  }

  .auth-buttons {
    flex-direction: column;
    gap: 12px;
  }

  .image-preview img {
    max-width: 150px;
  }
}

@media (max-width: 640px) {
  .recent-post-grid {
    grid-template-columns: 1fr;
  }

  .top-post-card {
    padding: 12px;
  }

  .top-post-title {
    font-size: 1.1rem;
  }

  .top-post-content {
    font-size: 0.9rem;
  }
}
.comment-actions {
  display: flex;
  gap: 8px;
  margin-top: 8px;
}

.comment-reply-btn {
  background: none;
  border: none;
  color: var(--primary-color, #2563eb);
  cursor: pointer;
  font-size: 0.9em;
}

.comment-reply-btn:hover {
  text-decoration: underline;
}

.comment-delete-btn {
  background: none;
  border: none;
  color: var(--error-color, #dc2626);
  cursor: pointer;
  display: flex;
  align-items: center;
}

.comment-delete-btn:hover {
  color: #b91c1c;
}
.blog-footer-container {
  background: linear-gradient(to right, #1a202c, #2d3748);
  color: #e2e8f0;
  padding: 3rem 1.5rem;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
}

.blog-footer-content {
  max-width: 1200px;
  margin: 0 auto;
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 2rem;
}

.blog-footer-brand {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.blog-footer-logo {
  font-size: 2rem;
  font-weight: bold;
  letter-spacing: -0.025em;
}

.blog-footer-description {
  color: #a0aec0;
  max-width: 250px;
  line-height: 1.5.-
}

.blog-footer-links-title,
.blog-footer-contact-title,
.blog-footer-social-title {
  font-size: 1.125rem;
  font-weight: 600;
  margin-bottom: 1rem;
}

.blog-footer-links-list {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.blog-footer-link {
  color: #a0aec0;
  text-decoration: none;
  transition: color 0.2s ease;
}

.blog-footer-link:hover {
  color: #ffffff;
}

.blog-footer-contact {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.blog-footer-form {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.blog-footer-input,
.blog-footer-textarea {
  background: #2d3748;
  color: #e2e8f0;
  border: 1px solid #4a5568;
  border-radius: 0.375rem;
  padding: 0.75rem;
  font-size: 0.875rem;
  transition: border-color 0.2s ease;
}

.blog-footer-input:focus,
.blog-footer-textarea:focus {
  outline: none;
  border-color: #3182ce;
  box-shadow: 0 0 0 2px rgba(49, 130, 206, 0.2);
}

.blog-footer-textarea {
  resize: none;
}

.blog-footer-button {
  background: #3182ce;
  color: #ffffff;
  border: none;
  border-radius: 0.375rem;
  padding: 0.75rem;
  font-size: 0.875rem;
  cursor: pointer;
  transition: background 0.2s ease;
}

.blog-footer-button:hover {
  background: #2b6cb0;
}

.blog-footer-form-status {
  font-size: 0.75rem;
  color: #a0aec0;
}

.blog-footer-social-icons {
  display: flex;
  gap: 1rem;
}

.blog-footer-social-icon {
  color: #a0aec0;
  font-size: 1.5rem;
  transition: color 0.2s ease;
}

.blog-footer-social-icon:hover {
  color: #ffffff;
}

.blog-footer-copyright {
  border-top: 1px solid #4a5568;
  margin-top: 2rem;
  padding-top: 1.5rem;
  text-align: center;
  color: #a0aec0;
  font-size: 0.875rem;
}

/* Responsive Design */
@media (max-width: 768px) {
  .blog-footer-content {
    grid-template-columns: 1fr;
  }

  .blog-footer-brand,
  .blog-footer-links,
  .blog-footer-contact,
  .blog-footer-social {
    text-align: center;
  }

  .blog-footer-description {
    max-width: 100%;
  }

  .blog-footer-social-icons {
    justify-content: center;
  }
}

app\layout.tsx
import { ClerkProvider } from '@clerk/nextjs'
import { ThemeProvider } from './components/ThemeProvider'
import './globals.css'
import Navbar from '@/components/Navbar'
export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <ClerkProvider>
      <html lang="en" dir="ltr">
        <body>
          <ThemeProvider>
            <Navbar />
            <main style={{ paddingTop: '70px' }}>{children}</main>
          </ThemeProvider>
        </body>
      </html>
    </ClerkProvider>
  )
}

app\page.module.css
.page {
  --gray-rgb: 0, 0, 0;
  --gray-alpha-200: rgba(var(--gray-rgb), 0.08);
  --gray-alpha-100: rgba(var(--gray-rgb), 0.05);

  --button-primary-hover: #383838;
  --button-secondary-hover: #f2f2f2;

  display: grid;
  grid-template-rows: 20px 1fr 20px;
  align-items: center;
  justify-items: center;
  min-height: 100svh;
  padding: 80px;
  gap: 64px;
  font-family: var(--font-geist-sans);
}

@media (prefers-color-scheme: dark) {
  .page {
    --gray-rgb: 255, 255, 255;
    --gray-alpha-200: rgba(var(--gray-rgb), 0.145);
    --gray-alpha-100: rgba(var(--gray-rgb), 0.06);

    --button-primary-hover: #ccc;
    --button-secondary-hover: #1a1a1a;
  }
}

.main {
  display: flex;
  flex-direction: column;
  gap: 32px;
  grid-row-start: 2;
}

.main ol {
  font-family: var(--font-geist-mono);
  padding-left: 0;
  margin: 0;
  font-size: 14px;
  line-height: 24px;
  letter-spacing: -0.01em;
  list-style-position: inside;
}

.main li:not(:last-of-type) {
  margin-bottom: 8px;
}

.main code {
  font-family: inherit;
  background: var(--gray-alpha-100);
  padding: 2px 4px;
  border-radius: 4px;
  font-weight: 600;
}

.ctas {
  display: flex;
  gap: 16px;
}

.ctas a {
  appearance: none;
  border-radius: 128px;
  height: 48px;
  padding: 0 20px;
  border: none;
  border: 1px solid transparent;
  transition:
    background 0.2s,
    color 0.2s,
    border-color 0.2s;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  line-height: 20px;
  font-weight: 500;
}

a.primary {
  background: var(--foreground);
  color: var(--background);
  gap: 8px;
}

a.secondary {
  border-color: var(--gray-alpha-200);
  min-width: 158px;
}

.footer {
  grid-row-start: 3;
  display: flex;
  gap: 24px;
}

.footer a {
  display: flex;
  align-items: center;
  gap: 8px;
}

.footer img {
  flex-shrink: 0;
}

/* Enable hover only on non-touch devices */
@media (hover: hover) and (pointer: fine) {
  a.primary:hover {
    background: var(--button-primary-hover);
    border-color: transparent;
  }

  a.secondary:hover {
    background: var(--button-secondary-hover);
    border-color: transparent;
  }

  .footer a:hover {
    text-decoration: underline;
    text-underline-offset: 4px;
  }
}

@media (max-width: 600px) {
  .page {
    padding: 32px;
    padding-bottom: 80px;
  }

  .main {
    align-items: center;
  }

  .main ol {
    text-align: center;
  }

  .ctas {
    flex-direction: column;
  }

  .ctas a {
    font-size: 14px;
    height: 40px;
    padding: 0 16px;
  }

  a.secondary {
    min-width: auto;
  }

  .footer {
    flex-wrap: wrap;
    align-items: center;
    justify-content: center;
  }
}

@media (prefers-color-scheme: dark) {
  .logo {
    filter: invert();
  }
}


app\page.tsx
import PostList from "@/components/PostList";
import SearchBox from "@/components/SearchBox";
import { currentUser } from "@clerk/nextjs/server";
import Footer from "./components/Footer";

export default async function Home({ searchParams }: { searchParams: { q?: string } }) {
  const searchQuery = searchParams.q || '';
  const user = await currentUser();

  return (
    <div className="container">
      <h2 style={{ fontSize: '1.75rem', fontWeight: 600, marginBottom: '16px' }}>
Well Come to Blgo Platform      </h2>
      <p style={{ marginBottom: '16px', color: '#4b5563' }}>
        Search Posts 
      </p>
      <SearchBox defaultValue={searchQuery} formAction="/" />
      <div className="container">
        {user ? (
          <PostList searchQuery={searchQuery} isAllPosts={false} />
        ) : (
          <div>
            <h1 className="profile-title"> Well Come</h1>
            <p style={{ fontSize: '18px', marginBottom: '16px' }}>
                    Log in To See Your Posts  {' '}
              <a href="/all-posts" className="author-link">
                All Posts
              </a>{' '}
              Go.
            </p>
          </div>
        )}
      </div>
      <Footer/>
    </div>
  );
}

app\posts\[id]\page.tsx
'use client';

import { useState, useEffect } from 'react';
import { useUser } from '@clerk/nextjs';
import { useRouter } from 'next/navigation';
import Link from 'next/link';
import { Heart, Star } from 'lucide-react';
import CommentSection from '@/components/CommentSection';

type Post = {
  id: string;
  title: string;
  content: string;
  author: string;
  created_at: string;
  imageUrl?: string;
  authorName?: string;
  updated_at?: string;
  favorited_at?: string;
};

type LikeStatus = {
  likesCount: number;
  userLiked: boolean;
};

type FavoriteStatus = {
  favoritesCount: number;
  userFavorited: boolean;
};

export default function PostDetail({ params }: { params: { id: string } }) {
  const [post, setPost] = useState<Post | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [likeStatus, setLikeStatus] = useState<LikeStatus>({ likesCount: 0, userLiked: false });
  const [favoriteStatus, setFavoriteStatus] = useState<FavoriteStatus>({ favoritesCount: 0, userFavorited: false });
  const { user } = useUser();
  const router = useRouter();

  useEffect(() => {
    async function fetchPost() {
      try {
        const cleanPostId = params.id.split(':')[1] || params.id;
        console.log('Fetching post with ID:', cleanPostId);
        const response = await fetch(`/api/posts/${cleanPostId}`);
        if (!response.ok) {
          const errorData = await response.json();
          console.error('API error response:', errorData);
          throw new Error(errorData.error || 'Failed to fetch post');
        }
        const data = await response.json();
        console.log('Fetched post data:', data);
        setPost(data);
        setError(null);

        const likeRes = await fetch(`/api/likes/${cleanPostId}`);
        if (likeRes.ok) {
          setLikeStatus(await likeRes.json());
        } else {
          console.error('Failed to fetch like status:', await likeRes.json());
        }
        const favoriteRes = await fetch(`/api/favorites/${cleanPostId}`);
        if (favoriteRes.ok) {
          setFavoriteStatus(await favoriteRes.json());
        } else {
          console.error('Failed to fetch favorite status:', await favoriteRes.json());
        }
      } catch (err: any) {
        console.error(`Error fetching post: ${err.message}`);
        setError(err.message);
      }
    }
    fetchPost();
  }, [params.id]);

  const handleDelete = async (id: string) => {
    try {
      if (!user) {
        setError('Please sign in to delete a post');
        return;
      }

      const postId = id.split(':')[1];
      console.log(`Sending DELETE request for post: ${postId}`);

      const response = await fetch(`/api/posts/${postId}/delete`, {
        method: 'DELETE',
      });
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Error deleting post');
      }

      const result = await response.json();
      console.log('DELETE RESPONSE =>', result);
      router.push('/posts');
      setError(null);
    } catch (err: any) {
      console.error(`Delete error: ${err.message}`);
      setError(err.message || 'Error deleting post');
    }
  };

  const handleLike = async (postId: string) => {
    if (!user) {
      setError('Please sign in to like a post');
      return;
    }

    try {
      const response = await fetch(`/api/likes/${postId.split(':')[1]}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Error liking post');
      }

      const { liked } = await response.json();
      setLikeStatus((prev) => ({
        likesCount: liked ? prev.likesCount + 1 : prev.likesCount - 1,
        userLiked: liked,
      }));
      setError(null);
    } catch (err: any) {
      console.error(`Like error: ${err.message}`);
      setError(err.message || 'Error liking post');
    }
  };

  const handleFavorite = async (postId: string) => {
    if (!user) {
      setError('Please sign in to add to favorites');
      return;
    }

    try {
      const response = await fetch(`/api/favorites/${postId.split(':')[1]}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Error adding to favorites');
      }

      const { favorited } = await response.json();
      setFavoriteStatus((prev) => ({
        favoritesCount: favorited ? prev.favoritesCount + 1 : prev.favoritesCount - 1,
        userFavorited: favorited,
      }));
      setError(null);
    } catch (err: any) {
      console.error(`Favorite error: ${err.message}`);
      setError(err.message || 'Error adding to favorites');
    }
  };

  if (error) return <div className="container">خطا: {error}</div>;
  if (!post) return <div className="container">در حال بارگذاری...</div>;

  return (
    <div className="container">
      <div className="post">
        <Link href={`/posts/${post.id.split(':')[1]}`}>
          {post.imageUrl && <img src={post.imageUrl} alt={post.title} className="post-image" />}
          {post.title}
        </Link>
        <h4></h4>
        <p className="post-content">{post.content}</p>
        <p className="meta">
        Author:{' '}
          <Link href={`/profile/${post.author}`} className="author-link">
            {post.authorName || post.author || 'ناشناس'}
          </Link>
        </p>
        <p className="meta">
         Post Date {new Date(post.created_at).toLocaleDateString('en-US')}
        </p>
        {post.updated_at && (
          <p className="meta">
            به‌روزرسانی: {new Date(post.updated_at).toLocaleDateString('fa-IR')}
          </p>
        )}
        <div className="like-favorite-section">
          <div className="like-section">
            <button
              onClick={() => handleLike(post.id)}
              className={`like-button ${likeStatus.userLiked ? 'liked' : ''}`}
              disabled={!user}
              data-tooltip="لایک"
            >
              <Heart
                size={20}
                fill={likeStatus.userLiked ? '#dc2626' : 'none'}
                color={likeStatus.userLiked ? '#dc2626' : '#4b5563'}
              />
            </button>
            <span className="like-count">{likeStatus.likesCount || 0}</span>
          </div>
          <div className="favorite-section">
            <button
              onClick={() => handleFavorite(post.id)}
              className={`favorite-button ${favoriteStatus.userFavorited ? 'favorited' : ''}`}
              disabled={!user}
              data-tooltip="علاقه‌مندی"
            >
              <Star
                size={20}
                fill={favoriteStatus.userFavorited ? '#eab308' : 'none'}
                color={favoriteStatus.userFavorited ? '#eab308' : '#4b5563'}
              />
            </button>
            <span className="favorite-count">{favoriteStatus.favoritesCount || 0}</span>
          </div>
        </div>
        {user && (
          <div className="actions">
            {post.author === user.id && (
              <button
                className="edit"
                onClick={() => router.push(`/edit-post/${post.id.split(':')[1]}`)}
              >
                ویرایش
              </button>
            )}
            {(post.author === user.id || (user?.publicMetadata?.role === 'admin')) && (
              <button className="delete" onClick={() => handleDelete(post.id)}>
                حذف
              </button>
            )}
          </div>
        )}
      </div>
      <CommentSection postId={params.id} user={user} />
    </div>
  );
}

app\profile\[userId]\page.tsx
import { clerkClient } from '@clerk/nextjs/server';
import PostList from '@/components/PostList';
import SearchBox from '@/components/SearchBox';

type Props = {
  params: { userId: string };
  searchParams: { q?: string };
};

export default async function ProfilePage({ params, searchParams }: Props) {
  const { userId } = params;
  const searchQuery = searchParams.q || '';

  try {
    // گرفتن اطلاعات کاربر از Clerk
    const clerk = await clerkClient();
    const user = await clerk.users.getUser(userId);
    const authorName =
      user.firstName || user.fullName || user.emailAddresses[0]?.emailAddress || 'Unknown Email';
    const profileImage = user.imageUrl || '/default-avatar.png';

    return (
      <div className="container">
        <h1 className="profile-title">Profile {authorName}</h1>
        <div className="profile-info">
          <img src={profileImage} alt={authorName} className="profile-image" />
          <div>
            <p>
              <strong>Name:</strong>
              {user.firstName || user.fullName || 'ناشناس'}
            </p>
            <p>
              <strong>Email:</strong>
              {user.emailAddresses[0]?.emailAddress || 'ایمیل ناشناس'}
            </p>
            <p>
              <strong>Last Activity:</strong>
              {new Date(user.updatedAt).toLocaleDateString('en-US') || 'ناشناس'}
            </p>
            <p>
              <strong>Account Created at:</strong>
              {new Date(user.createdAt).toLocaleDateString('en-US') || 'ناشناس'}
            </p>
          </div>
        </div>
        <SearchBox
          defaultValue={searchQuery}
          placeholder="Searching For This User`s Posts"
          formAction={`/profile/${userId}`}
        />
        <PostList searchQuery={searchQuery} authorId={userId} />
      </div>
    );
  } catch (error: any) {
    return (
      <div className="container">
        <h1 className="profile-title">Error</h1>
        <p className="profile-error">Error to Get User Profile{error.message}</p>
      </div>
    );
  }
}

app\sign-in\[[...sign-in]]\page.tsx
import { SignIn } from "@clerk/nextjs";





   export default function SignInPage() {
     return <SignIn />;
   }

app\sign-up\[[...sign-up]]\page.tsx
import { SignUp } from "@clerk/nextjs";

   export default function SignUpPage() {
     return <SignUp />;
   }

components\AuthButtons.tsx
'use client';

import { SignInButton, SignedIn, SignedOut, UserButton, SignUpButton, useUser } from '@clerk/nextjs';
import Link from 'next/link';

export default function AuthButtons() {
  const { user } = useUser();
  const isAdmin = user?.publicMetadata?.role === 'admin';

  return (
    <div className="auth-buttons">
      <SignedIn>
        <div className="auth-buttons">
          <UserButton afterSignOutUrl="/" />
          <Link href="/create-post">
            <button className="clerk-button create-post">Create New Post</button>
          </Link>
          {isAdmin && (
            <Link href="/admin">
              <button className="clerk-button admin-panel">Admin Panel</button>
            </Link>
          )}
        </div>
      </SignedIn>
      <SignedOut>
        <div className="auth-buttons">
          <SignInButton mode="modal">
            <button className="clerk-button sign-in">Sign In</button>
          </SignInButton>
          <SignUpButton mode="modal">
            <button className="clerk-button sign-up">Sign Up</button>
          </SignUpButton>
        </div>
      </SignedOut>
    </div>
  );
}

components\CommentForm.tsx
'use client';

import { useState } from 'react';

type CommentFormProps = {
  postId: string;
  user: any;
  parentId?: string | null;
  onCommentAdded?: () => void;
};

export default function CommentForm({ postId, user, parentId, onCommentAdded }: CommentFormProps) {
  const [content, setContent] = useState('');
  const [error, setError] = useState<string | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!user) {
      setError('برای ارسال کامنت باید وارد شوید');
      return;
    }
    if (!content.trim()) {
      setError('محتوای کامنت نمی‌تواند خالی باشد');
      return;
    }

    setIsSubmitting(true);
    setError(null);

    try {
      const response = await fetch('/api/comments', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          postId,
          content,
          parentId,
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'خطا در ارسال کامنت');
      }

      setContent('');
      if (onCommentAdded) onCommentAdded();
    } catch (err: any) {
      setError(err.message);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="comment-form">
      <textarea
        value={content}
        onChange={(e) => setContent(e.target.value)}
        placeholder={parentId ? 'Write Reply' : 'Write Your Comment'}
        disabled={isSubmitting}
      />
      {error && <p className="error">{error}</p>}
      <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? 'Sending...' : parentId ? 'Send Reply ' : 'Send Comment'}
      </button>
    </form>
  );
}

components\CommentList.tsx
'use client';

import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import CommentForm from './CommentForm';
import { Trash2 } from 'lucide-react';

type Comment = {
  id: string;
  postId: string;
  content: string;
  author: string;
  created_at: string;
  authorName: string;
  parentId?: string | null;
  replies?: Comment[];
};

type CommentListProps = {
  postId: string;
  user: any;
  onCommentAdded: () => void;
};

export default function CommentList({ postId, user, onCommentAdded }: CommentListProps) {
  const [comments, setComments] = useState<Comment[]>([]);
  const [replyingTo, setReplyingTo] = useState<string | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const router = useRouter();

  useEffect(() => {
    const fetchComments = async () => {
      try {
        setLoading(true);
        setError(null);
        const cleanPostId = postId.split(':')[1] || postId;
        const response = await fetch(`/api/comments/post/${cleanPostId}`);
        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.error || `خطا در گرفتن کامنت‌ها: ${response.status}`);
        }
        const data = await response.json();
        console.log('Fetched comments:', data); // برای دیباگ
        setComments(data);
      } catch (err: any) {
        console.error('Error fetching comments:', err);
        setError('خطا در گرفتن کامنت‌ها: ' + err.message);
      } finally {
        setLoading(false);
      }
    };

    fetchComments();
  }, [postId, onCommentAdded]);

  const handleReplyClick = (commentId: string) => {
    setReplyingTo(replyingTo === commentId ? null : commentId);
  };

  const handleAuthorClick = (userId: string) => {
    router.push(`/profile/${userId}`);
  };

  const handleDelete = async (commentId: string) => {
    if (!user) {
      alert('برای حذف کامنت باید وارد شوید');
      return;
    }

    if (!confirm('آیا مطمئن هستید که می‌خواهید این کامنت را حذف کنید؟')) {
      return;
    }

    try {
      const cleanCommentId = commentId.split(':')[1] || commentId;
      const response = await fetch(`/api/comments/${cleanCommentId}`, {
        method: 'DELETE',
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'خطا در حذف کامنت');
      }

      onCommentAdded(); // Refresh comments
    } catch (err: any) {
      alert('خطا در حذف کامنت: ' + err.message);
    }
  };

  const renderComment = (comment: Comment, depth: number = 0) => {
    return (
      <div key={comment.id} className={`comment ${depth > 0 ? 'reply' : ''}`} style={{ marginLeft: `${depth * 20}px` }}>
        <p>
          <span className="author-name" onClick={() => handleAuthorClick(comment.author)}>
            {comment.authorName}
          </span>: {comment.content}
        </p>
        <p className="comment-date">
          {new Date(comment.created_at).toLocaleDateString('fa-IR')}
        </p>
        <div className="comment-actions">
          {user && (
            <button className="comment-reply-btn" onClick={() => handleReplyClick(comment.id)}>
              Reply
            </button>
          )}
          {user && comment.author === user.id && (
            <button className="comment-delete-btn" onClick={() => handleDelete(comment.id)} title="حذف کامنت">
              <Trash2 size={16} />
            </button>
          )}
        </div>
        {replyingTo === comment.id && user && (
          <CommentForm
            postId={postId}
            user={user}
            parentId={comment.id}
            onCommentAdded={onCommentAdded}
          />
        )}
        {comment.replies && comment.replies.length > 0 && (
          <div className="replies">
            {comment.replies.map((reply) => renderComment(reply, depth + 1))}
          </div>
        )}
      </div>
    );
  };

  if (error) {
    return <div className="container">Error: {error}</div>;
  }

  if (loading) {
    return <div className="container">Uploading...</div>;
  }

  if (comments.length === 0) {
    return <div className="container">There is no Comment</div>;
  }

  return <div className="comment-list">{comments.map((comment) => renderComment(comment))}</div>;
}

components\CommentSection.tsx
'use client';

import { useState, useEffect } from 'react';
import CommentList from './CommentList';
import CommentForm from './CommentForm';

type Comment = {
  id: string;
  postId: string;
  content: string;
  author: string;
  created_at: string;
  authorName: string;
  parentId?: string | null;
  replies?: Comment[];
};

type Props = {
  postId: string;
  user: any;
};

export default function CommentSection({ postId, user }: Props) {
  const [comments, setComments] = useState<Comment[]>([]);

  const fetchComments = async () => {
    try {
      const response = await fetch(`/api/comments/post/${postId}`);
      if (!response.ok) throw new Error('خطا تو لود کامنت‌ها');
      const data = await response.json();
      setComments(data);
    } catch (err: any) {
      console.error(err.message);
    }
  };

  useEffect(() => {
    fetchComments();
  }, [postId]);

  return (
    <div className="comment-section">
      <h3>Comments</h3>
      {user ? (
        <CommentForm postId={postId} user={user} parentId={null} onCommentAdded={fetchComments} />
      ) : (
        <p>Sign In to Comment</p>
      )}
      <CommentList comments={comments} postId={postId} user={user} onCommentAdded={fetchComments} />
    </div>
  );
}

components\Navbar.tsx
'use client'

import { useState } from 'react'
import Link from 'next/link'
import { Menu, X, Sun, Moon } from 'lucide-react'
import { useUser } from '@clerk/nextjs'
import AuthButtons from './AuthButtons'
import { useTheme } from '@/app/components/ThemeProvider'

function ThemeToggleButton() {
  const { theme, toggleTheme } = useTheme()

  return (
    <button
      onClick={toggleTheme}
      className="theme-toggle-btn"
      aria-label={`Switch to ${theme === 'light' ? 'dark' : 'light'} mode`}
    >
      {theme === 'light' ? (
        <Moon size={24} className="theme-toggle-icon" />
      ) : (
        <Sun size={24} className="theme-toggle-icon" />
      )}
    </button>
  )
}

export default function Navbar() {
  const [isMenuOpen, setIsMenuOpen] = useState(false)
  const { isSignedIn } = useUser()

  const toggleMenu = () => setIsMenuOpen(!isMenuOpen)

  return (
    <nav className="site-nav">
      <div className="container">
        {/* Logo */}
        <Link href="/" className="logo">
          Blog Platform
        </Link>

        {/* Desktop Menu */}
        <div className="desktop-menu">
          <Link href="/">Home</Link>
          <Link href="/all-posts">All Posts</Link>
          {isSignedIn && <Link href="/favorites">Favorites</Link>}
          <AuthButtons />
          <ThemeToggleButton />
        </div>

        {/* Mobile Menu Button */}
        <button className="mobile-menu-button" onClick={toggleMenu}>
          {isMenuOpen ? <X size={24} /> : <Menu size={24} />}
        </button>
      </div>

      {/* Mobile Menu */}
      <div className={`mobile-menu ${isMenuOpen ? 'active' : ''}`}>
        <div className="container">
          <Link href="/" onClick={toggleMenu}>
            Home
          </Link>
          <Link href="/all-posts" onClick={toggleMenu}>
            All Posts
          </Link>
          {isSignedIn && (
            <Link href="/favorites" onClick={toggleMenu}>
              Favorites
            </Link>
          )}
          <AuthButtons />
          <ThemeToggleButton />
        </div>
      </div>
    </nav>
  )
}

components\PostList.tsx
'use client'

import { useState, useEffect } from 'react'
import { useUser } from '@clerk/nextjs'
import { useRouter } from 'next/navigation'
import Link from 'next/link'
import { Heart, Star } from 'lucide-react'

type Post = {
  id: string
  title: string
  content: string
  author: string
  created_at: string
  imageUrl?: string
  authorName: string
  updated_at?: string
  favorited_at?: string
}

type LikeStatus = {
  likesCount: number
  userLiked: boolean
}

type FavoriteStatus = {
  favoritesCount: number
  userFavorited: boolean
}

type Props = {
  searchQuery: string
  isAllPosts?: boolean
  isFavorites?: boolean
  authorId?: string
  isAdmin?: boolean
  deleteAdmin?: boolean
}

export default function PostList({
  searchQuery,
  isAllPosts = false,
  isFavorites = false,
  authorId,
  isAdmin = false,
  deleteAdmin = false,
}: Props) {
  const [posts, setPosts] = useState<Post[]>([])
  const [error, setError] = useState<string | null>(null)
  const [likeStatuses, setLikeStatuses] = useState<{ [key: string]: LikeStatus }>({})
  const [favoriteStatuses, setFavoriteStatuses] = useState<{ [key: string]: FavoriteStatus }>({})
  const { user } = useUser()
  const router = useRouter()

  useEffect(() => {
    async function fetchPosts() {
      try {
        let url: string
        if (isFavorites) {
          if (!user) {
            setError('Please sign in to view your favorite posts')
            return
          }
          url = searchQuery
            ? `/api/favorites/user?q=${encodeURIComponent(searchQuery)}`
            : '/api/favorites/user'
        } else if (searchQuery) {
          url = `/api/posts/search?q=${encodeURIComponent(searchQuery)}`
        } else if (authorId) {
          url = `/api/posts/by-author/${authorId}`
        } else if (isAllPosts) {
          url = '/api/posts'
        } else {
          if (!user) {
            setError('Please sign in to view your posts')
            return
          }
          url = '/api/user-posts'
        }

        console.log(`Fetching posts from: ${url}`)
        const response = await fetch(url)
        if (!response.ok) {
          const errorData = await response.json()
          throw new Error(errorData.error || 'Error fetching posts')
        }

        const fetchedPosts: Post[] = await response.json()
        console.log('Fetched posts in PostList:', fetchedPosts) // Enhanced log for debugging
        setPosts(fetchedPosts)
        setError(null)

        // Fetch like and favorite status for each post
        const likeStatuses: { [key: string]: LikeStatus } = {}
        const favoriteStatuses: { [key: string]: FavoriteStatus } = {}
        await Promise.all(
          fetchedPosts.map(async (post: Post) => {
            // Fetch likes
            const likeRes = await fetch(`/api/likes/${post.id.split(':')[1]}`)
            if (likeRes.ok) {
              likeStatuses[post.id] = await likeRes.json()
            }
            // Fetch favorites
            const favoriteRes = await fetch(`/api/favorites/${post.id.split(':')[1]}`)
            if (favoriteRes.ok) {
              favoriteStatuses[post.id] = await favoriteRes.json()
            }
          })
        )
        console.log('Like statuses:', likeStatuses) // Log for debugging
        console.log('Favorite statuses:', favoriteStatuses) // Log for debugging
        setLikeStatuses(likeStatuses)
        setFavoriteStatuses(favoriteStatuses)
      } catch (err: any) {
        console.error(`Fetch posts error: ${err.message}`)
        setError(err.message || 'Error fetching posts')
      }
    }

    fetchPosts()
  }, [user, searchQuery, isAllPosts, isFavorites, authorId])

  const handleDelete = async (id: string) => {
    try {
      if (!user) {
        setError('Please sign in to delete a post')
        return
      }

      const postId = id.split(':')[1]
      console.log(`Sending DELETE request for post: ${postId}`)

      const response = await fetch(`/api/posts/${postId}/delete`, {
        method: 'DELETE',
      })
      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || 'Error deleting post')
      }

      const result = await response.json()
      console.log('DELETE RESPONSE =>', result)

      setPosts(posts.filter((post) => post.id !== id))
      setError(null)
    } catch (err: any) {
      console.error(`Delete error: ${err.message}`)
      setError(err.message || 'Error deleting post')
    }
  }

  const handleLike = async (postId: string) => {
    if (!user) {
      setError('Please sign in to like a post')
      return
    }

    try {
      const response = await fetch(`/api/likes/${postId.split(':')[1]}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || 'Error liking post')
      }

      const { liked } = await response.json()
      setLikeStatuses((prev) => ({
        ...prev,
        [postId]: {
          likesCount: liked ? prev[postId].likesCount + 1 : prev[postId].likesCount - 1,
          userLiked: liked,
        },
      }))
      setError(null)
    } catch (err: any) {
      console.error(`Like error: ${err.message}`)
      setError(err.message || 'Error liking post')
    }
  }

  const handleFavorite = async (postId: string) => {
    if (!user) {
      setError('Please sign in to add to favorites')
      return
    }

    try {
      const response = await fetch(`/api/favorites/${postId.split(':')[1]}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || 'Error adding to favorites')
      }

      const { favorited } = await response.json()
      setFavoriteStatuses((prev) => ({
        ...prev,
        [postId]: {
          favoritesCount: favorited
            ? prev[postId].favoritesCount + 1
            : prev[postId].favoritesCount - 1,
          userFavorited: favorited,
        },
      }))
      setError(null)
    } catch (err: any) {
      console.error(`Favorite error: ${err.message}`)
      setError(err.message || 'Error adding to favorites')
    }
  }

  return (
    <div>
      <h3 style={{ fontSize: '1.5rem', fontWeight: 600, marginBottom: '16px' }}>
        {isFavorites
          ? 'Your Favorite Posts'
          : isAllPosts
          ? 'All Posts'
          : authorId
          ? 'Author Posts'
          : 'Your Posts'}
      </h3>
      {error && (
        <p className="error" style={{ marginBottom: '16px' }}>
          {error}
        </p>
      )}
      {posts.length === 0 && !error ? (
        <p style={{ color: '#4b5563' }}>
          No Post Found{' '}
          {isAllPosts || authorId || isFavorites
            ? ''
            : 'Create a New Post or Search For Another Post!!'}
        </p>
      ) : (
        posts.map((post) => (
          <div key={post.id} className="post">
            <Link href={`/posts/${post.id.split(':')[1]}`}>
              {post.imageUrl && <img src={post.imageUrl} alt={post.title} className="post-image" />}
              {post.title}
            </Link>
            <h4></h4>
            <p className="post-content">{post.content}</p>
            <p className="meta">
              Author:{' '}
              <Link href={`/profile/${post.author}`} className="author-link">
                {post.authorName}
              </Link>
            </p>
            <p className="meta">
              Post Date: {new Date(post.created_at).toLocaleDateString('en-US')}
            </p>
            {post.updated_at && (
              <p className="meta">
                Updated at: {new Date(post.updated_at).toLocaleDateString('en-US')}
              </p>
            )}
            <div className="like-favorite-section">
              <div className="like-section">
                <button
                  onClick={() => handleLike(post.id)}
                  className={`like-button ${likeStatuses[post.id]?.userLiked ? 'liked' : ''}`}
                  disabled={!user}
                  data-tooltip="Like"
                >
                  <Heart
                    size={20}
                    fill={likeStatuses[post.id]?.userLiked ? '#dc2626' : 'none'}
                    color={likeStatuses[post.id]?.userLiked ? '#dc2626' : '#4b5563'}
                  />
                </button>
                <span className="like-count">{likeStatuses[post.id]?.likesCount || 0}</span>
              </div>
              <div className="favorite-section">
                <button
                  onClick={() => handleFavorite(post.id)}
                  className={`favorite-button ${
                    favoriteStatuses[post.id]?.userFavorited ? 'favorited' : ''
                  }`}
                  disabled={!user}
                  data-tooltip="Favorite"
                >
                  <Star
                    size={20}
                    fill={favoriteStatuses[post.id]?.userFavorited ? '#eab308' : 'none'}
                    color={favoriteStatuses[post.id]?.userFavorited ? '#eab308' : '#4b5563'}
                  />
                </button>
                <span className="favorite-count">
                  {favoriteStatuses[post.id]?.favoritesCount || 0}
                </span>
              </div>
            </div>
            {user && (
              <div className="actions">
                {post.author === user.id && (
                  <button
                    className="edit"
                    onClick={() => router.push(`/edit-post/${post.id.split(':')[1]}`)}
                  >
                    Edit
                  </button>
                )}
                {(post.author === user.id ||
                  (deleteAdmin && user.publicMetadata?.role === 'admin')) && (
                  <button className="delete" onClick={() => handleDelete(post.id)}>
                    Delete
                  </button>
                )}
              </div>
            )}
          </div>
        ))
      )}
    </div>
  )
}


components\SearchBox.tsx
'use client';

import { useState } from 'react';

type Props = {
  defaultValue?: string;
  placeholder?: string;
  className?: string;
  formAction?: string; // URL پایه برای ریدایرکت
};

export default function SearchBox({
  defaultValue = '',
  placeholder = 'Searching...',
  className = '',
  formAction = '/', // به طور پیش‌فرض به صفحه اصلی
}: Props) {
  const [searchQuery, setSearchQuery] = useState(defaultValue);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    // ریدایرکت به URL پایه با کوئری جستجو
    window.location.href = `${formAction}?q=${encodeURIComponent(searchQuery)}`;
  };

  const handleClear = () => {
    setSearchQuery('');
    // ریدایرکت به URL پایه بدون کوئری
    window.location.href = formAction;
  };

  return (
    <div style={{ marginBottom: '24px' }} className={className}>
      <form onSubmit={handleSubmit} action={formAction} method="GET" style={{ position: 'relative' }}>
        <input
          type="text"
          name="q"
          placeholder={placeholder}
          value={searchQuery}
          onChange={(e) => setSearchQuery(e.target.value)}
          style={{
            width: '100%',
            padding: '12px 40px 12px 12px', // فضای کافی برای آیکون‌ها
            border: '1px solid #d1d5db',
            borderRadius: '6px',
            fontSize: '1rem',
          }}
        />
        {/* آیکون ضربدر برای پاک کردن */}
        {searchQuery && (
          <button
            type="button"
            onClick={handleClear}
            style={{
              position: 'absolute',
              right: '40px',
              top: '50%',
              transform: 'translateY(-50%)',
              background: 'none',
              border: 'none',
              cursor: 'pointer',
            }}
            aria-label="Clear Searching..."
          >
            <svg
              width="16"
              height="16"
              viewBox="0 0 24 24"
              fill="none"
              stroke="#4b5563"
              strokeWidth="2"
            >
              <path d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        )}
        {/* آیکون ذره‌بین برای جستجو */}
        <button
          type="submit"
          style={{
            position: 'absolute',
            right: '10px',
            top: '50%',
            transform: 'translateY(-50%)',
            background: 'none',
            border: 'none',
            cursor: 'pointer',
          }}
          aria-label="Search"
        >
          <svg
            width="16"
            height="16"
            viewBox="0 0 24 24"
            fill="none"
            stroke="#4b5563"
            strokeWidth="2"
          >
            <circle cx="11" cy="11" r="8" />
            <path d="M21 21l-4.35-4.35" />
          </svg>
        </button>
      </form>
    </div>
  );
}

export-code.js
const fs = require("fs");
const path = require("path");

const OUTPUT_FILE = "project-code.txt";
const targetExtensions = [".js", ".jsx", ".ts", ".tsx", ".json", ".css"];

function readFilesRecursively(dir, output = []) {
  const items = fs.readdirSync(dir);

  items.forEach(item => {
    const fullPath = path.join(dir, item);
    const stats = fs.statSync(fullPath);

    if (stats.isDirectory()) {
      if (item === "node_modules" || item.startsWith(".")) return;
      readFilesRecursively(fullPath, output);
    } else {
      const ext = path.extname(item);
      if (targetExtensions.includes(ext)) {
        const content = fs.readFileSync(fullPath, "utf8");
        const relativePath = path.relative(__dirname, fullPath);
        output.push(`${relativePath}\n${content}\n`);
      }
    }
  });

  return output;
}

const result = readFilesRecursively(__dirname);
fs.writeFileSync(OUTPUT_FILE, result.join("\n"), "utf8");

console.log(`✅ All code exported to ${OUTPUT_FILE}`);


lib\surrealdb.ts
import {Surreal} from 'surrealdb'
const db = new Surreal()
  let isConnected = false

export const connectDB = async () => {
  if (isConnected) return
  try {
    // await db.connect("wss://saeed-06b66kijc1q7jc8ipd0mv9ii1s.aws-euw1.surreal.cloud", {
      await db.connect('ws://127.0.0.1:8000', {      namespace: "test",
      database: "test",
      auth: {
        username: "root",
        password: "root",
      }
    });
    isConnected = true
    console.log('Connect Shodid')
  } catch (error) {
    console.log('Connect Nashodid')
  }
}
export default db

middleware.ts
import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";

// مسیرهای خصوصی که نیاز به لاگین دارن
const isPrivateRoute = createRouteMatcher([
  "/create-post(.*)",
  "/edit-post(.*)",
  "/admin(.*)",
]);

export default clerkMiddleware(async (auth, request) => {
  if (isPrivateRoute(request)) {
    await auth.protect();
  }
});

export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    "/((?!_next|[^?]*\\.(?:html?|css|js|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)",
    // Always run for API routes
    "/(api|trpc)(.*)",
  ],
};

next-env.d.ts
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.


next.config.ts
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */  reactStrictMode: false, // این گاهی باعث جلوگیری از خطای hydration می‌شه

};

export default nextConfig;


package-lock.json
{
  "name": "blog-platform",
  "version": "0.1.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "blog-platform",
      "version": "0.1.0",
      "dependencies": {
        "@clerk/nextjs": "^6.18.0",
        "cloudinary": "^2.6.0",
        "framer-motion": "^12.10.1",
        "lucide-react": "^0.503.0",
        "next": "15.3.1",
        "react": "^19.0.0",
        "react-dom": "^19.0.0",
        "react-icons": "^5.5.0",
        "surrealdb": "^1.3.2"
      },
      "devDependencies": {
        "@types/node": "^20",
        "@types/react": "^19",
        "@types/react-dom": "^19",
        "autoprefixer": "^10.4.21",
        "postcss": "^8.5.3",
        "tailwindcss": "^4.1.5",
        "typescript": "^5"
      }
    },
    "node_modules/@clerk/backend": {
      "version": "1.30.0",
      "resolved": "https://registry.npmjs.org/@clerk/backend/-/backend-1.30.0.tgz",
      "integrity": "sha512-VB8a0jbfb5eiHENCT9ts8ISozUbKOcREj2rXQaYcOhEQ1EzO6Jng1Pb0nRR4RojsAvPe9XGMQrA4FufHp+dUWQ==",
      "license": "MIT",
      "dependencies": {
        "@clerk/shared": "^3.7.4",
        "@clerk/types": "^4.55.1",
        "cookie": "1.0.2",
        "snakecase-keys": "8.0.1",
        "tslib": "2.8.1"
      },
      "engines": {
        "node": ">=18.17.0"
      },
      "peerDependencies": {
        "svix": "^1.62.0"
      },
      "peerDependenciesMeta": {
        "svix": {
          "optional": true
        }
      }
    },
    "node_modules/@clerk/clerk-react": {
      "version": "5.30.0",
      "resolved": "https://registry.npmjs.org/@clerk/clerk-react/-/clerk-react-5.30.0.tgz",
      "integrity": "sha512-ruC8I31wu5vpYFTZ5Qj+avZwHbyzmhY6fatV6EzYMCIu7tOgDK5Af92gerfJ5drbRTL+NM4tDPmSNXiMIdS/nw==",
      "license": "MIT",
      "dependencies": {
        "@clerk/shared": "^3.7.4",
        "@clerk/types": "^4.55.1",
        "tslib": "2.8.1"
      },
      "engines": {
        "node": ">=18.17.0"
      },
      "peerDependencies": {
        "react": "^18.0.0 || ^19.0.0 || ^19.0.0-0",
        "react-dom": "^18.0.0 || ^19.0.0 || ^19.0.0-0"
      }
    },
    "node_modules/@clerk/nextjs": {
      "version": "6.18.0",
      "resolved": "https://registry.npmjs.org/@clerk/nextjs/-/nextjs-6.18.0.tgz",
      "integrity": "sha512-7cWFserYByK65eSX7eCyGXHlDb3ejNTyf3O8nHc4DgDLHjZn5dJA+6J0Hz1XSgUATOCSbnmkKSy1iekNMvSnYA==",
      "license": "MIT",
      "dependencies": {
        "@clerk/backend": "^1.30.0",
        "@clerk/clerk-react": "^5.30.0",
        "@clerk/shared": "^3.7.4",
        "@clerk/types": "^4.55.1",
        "server-only": "0.0.1",
        "tslib": "2.8.1"
      },
      "engines": {
        "node": ">=18.17.0"
      },
      "peerDependencies": {
        "next": "^13.5.7 || ^14.2.25 || ^15.2.3",
        "react": "^18.0.0 || ^19.0.0 || ^19.0.0-0",
        "react-dom": "^18.0.0 || ^19.0.0 || ^19.0.0-0"
      }
    },
    "node_modules/@clerk/shared": {
      "version": "3.7.4",
      "resolved": "https://registry.npmjs.org/@clerk/shared/-/shared-3.7.4.tgz",
      "integrity": "sha512-Ua6MyDyXjkfrV4h7ftC5LUsz7YL+0athsiNuMUyYjE3x8r/vmJzhLjZJ7C2C3KhDq2XnMWud0iQ7SGRTop+9WQ==",
      "hasInstallScript": true,
      "license": "MIT",
      "dependencies": {
        "@clerk/types": "^4.55.1",
        "dequal": "2.0.3",
        "glob-to-regexp": "0.4.1",
        "js-cookie": "3.0.5",
        "std-env": "^3.9.0",
        "swr": "^2.3.3"
      },
      "engines": {
        "node": ">=18.17.0"
      },
      "peerDependencies": {
        "react": "^18.0.0 || ^19.0.0 || ^19.0.0-0",
        "react-dom": "^18.0.0 || ^19.0.0 || ^19.0.0-0"
      },
      "peerDependenciesMeta": {
        "react": {
          "optional": true
        },
        "react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/@clerk/types": {
      "version": "4.55.1",
      "resolved": "https://registry.npmjs.org/@clerk/types/-/types-4.55.1.tgz",
      "integrity": "sha512-BS/shDMWfQ7M8Jlms/RJFH20N8cK1EfAWKTpiIiICFi5e/5H0gpaaWx277x341GQz4gZzVDPGdF+EhoknYOrWQ==",
      "license": "MIT",
      "dependencies": {
        "csstype": "3.1.3"
      },
      "engines": {
        "node": ">=18.17.0"
      }
    },
    "node_modules/@emnapi/runtime": {
      "version": "1.4.3",
      "resolved": "https://registry.npmjs.org/@emnapi/runtime/-/runtime-1.4.3.tgz",
      "integrity": "sha512-pBPWdu6MLKROBX05wSNKcNb++m5Er+KQ9QkB+WVM+pW2Kx9hoSrVTnu3BdkI5eBLZoKu/J6mW/B6i6bJB2ytXQ==",
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "tslib": "^2.4.0"
      }
    },
    "node_modules/@img/sharp-darwin-arm64": {
      "version": "0.34.1",
      "resolved": "https://registry.npmjs.org/@img/sharp-darwin-arm64/-/sharp-darwin-arm64-0.34.1.tgz",
      "integrity": "sha512-pn44xgBtgpEbZsu+lWf2KNb6OAf70X68k+yk69Ic2Xz11zHR/w24/U49XT7AeRwJ0Px+mhALhU5LPci1Aymk7A==",
      "cpu": [
        "arm64"
      ],
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-darwin-arm64": "1.1.0"
      }
    },
    "node_modules/@img/sharp-darwin-x64": {
      "version": "0.34.1",
      "resolved": "https://registry.npmjs.org/@img/sharp-darwin-x64/-/sharp-darwin-x64-0.34.1.tgz",
      "integrity": "sha512-VfuYgG2r8BpYiOUN+BfYeFo69nP/MIwAtSJ7/Zpxc5QF3KS22z8Pvg3FkrSFJBPNQ7mmcUcYQFBmEQp7eu1F8Q==",
      "cpu": [
        "x64"
      ],
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-darwin-x64": "1.1.0"
      }
    },
    "node_modules/@img/sharp-libvips-darwin-arm64": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-darwin-arm64/-/sharp-libvips-darwin-arm64-1.1.0.tgz",
      "integrity": "sha512-HZ/JUmPwrJSoM4DIQPv/BfNh9yrOA8tlBbqbLz4JZ5uew2+o22Ik+tHQJcih7QJuSa0zo5coHTfD5J8inqj9DA==",
      "cpu": [
        "arm64"
      ],
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "darwin"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-libvips-darwin-x64": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-darwin-x64/-/sharp-libvips-darwin-x64-1.1.0.tgz",
      "integrity": "sha512-Xzc2ToEmHN+hfvsl9wja0RlnXEgpKNmftriQp6XzY/RaSfwD9th+MSh0WQKzUreLKKINb3afirxW7A0fz2YWuQ==",
      "cpu": [
        "x64"
      ],
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "darwin"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-libvips-linux-arm": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-linux-arm/-/sharp-libvips-linux-arm-1.1.0.tgz",
      "integrity": "sha512-s8BAd0lwUIvYCJyRdFqvsj+BJIpDBSxs6ivrOPm/R7piTs5UIwY5OjXrP2bqXC9/moGsyRa37eYWYCOGVXxVrA==",
      "cpu": [
        "arm"
      ],
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "linux"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-libvips-linux-arm64": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-linux-arm64/-/sharp-libvips-linux-arm64-1.1.0.tgz",
      "integrity": "sha512-IVfGJa7gjChDET1dK9SekxFFdflarnUB8PwW8aGwEoF3oAsSDuNUTYS+SKDOyOJxQyDC1aPFMuRYLoDInyV9Ew==",
      "cpu": [
        "arm64"
      ],
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "linux"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-libvips-linux-ppc64": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-linux-ppc64/-/sharp-libvips-linux-ppc64-1.1.0.tgz",
      "integrity": "sha512-tiXxFZFbhnkWE2LA8oQj7KYR+bWBkiV2nilRldT7bqoEZ4HiDOcePr9wVDAZPi/Id5fT1oY9iGnDq20cwUz8lQ==",
      "cpu": [
        "ppc64"
      ],
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "linux"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-libvips-linux-s390x": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-linux-s390x/-/sharp-libvips-linux-s390x-1.1.0.tgz",
      "integrity": "sha512-xukSwvhguw7COyzvmjydRb3x/09+21HykyapcZchiCUkTThEQEOMtBj9UhkaBRLuBrgLFzQ2wbxdeCCJW/jgJA==",
      "cpu": [
        "s390x"
      ],
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "linux"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-libvips-linux-x64": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-linux-x64/-/sharp-libvips-linux-x64-1.1.0.tgz",
      "integrity": "sha512-yRj2+reB8iMg9W5sULM3S74jVS7zqSzHG3Ol/twnAAkAhnGQnpjj6e4ayUz7V+FpKypwgs82xbRdYtchTTUB+Q==",
      "cpu": [
        "x64"
      ],
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "linux"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-libvips-linuxmusl-arm64": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-linuxmusl-arm64/-/sharp-libvips-linuxmusl-arm64-1.1.0.tgz",
      "integrity": "sha512-jYZdG+whg0MDK+q2COKbYidaqW/WTz0cc1E+tMAusiDygrM4ypmSCjOJPmFTvHHJ8j/6cAGyeDWZOsK06tP33w==",
      "cpu": [
        "arm64"
      ],
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "linux"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-libvips-linuxmusl-x64": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/@img/sharp-libvips-linuxmusl-x64/-/sharp-libvips-linuxmusl-x64-1.1.0.tgz",
      "integrity": "sha512-wK7SBdwrAiycjXdkPnGCPLjYb9lD4l6Ze2gSdAGVZrEL05AOUJESWU2lhlC+Ffn5/G+VKuSm6zzbQSzFX/P65A==",
      "cpu": [
        "x64"
      ],
      "license": "LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "linux"
      ],
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-linux-arm": {
      "version": "0.34.1",
      "resolved": "https://registry.npmjs.org/@img/sharp-linux-arm/-/sharp-linux-arm-0.34.1.tgz",
      "integrity": "sha512-anKiszvACti2sGy9CirTlNyk7BjjZPiML1jt2ZkTdcvpLU1YH6CXwRAZCA2UmRXnhiIftXQ7+Oh62Ji25W72jA==",
      "cpu": [
        "arm"
      ],
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-linux-arm": "1.1.0"
      }
    },
    "node_modules/@img/sharp-linux-arm64": {
      "version": "0.34.1",
      "resolved": "https://registry.npmjs.org/@img/sharp-linux-arm64/-/sharp-linux-arm64-0.34.1.tgz",
      "integrity": "sha512-kX2c+vbvaXC6vly1RDf/IWNXxrlxLNpBVWkdpRq5Ka7OOKj6nr66etKy2IENf6FtOgklkg9ZdGpEu9kwdlcwOQ==",
      "cpu": [
        "arm64"
      ],
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-linux-arm64": "1.1.0"
      }
    },
    "node_modules/@img/sharp-linux-s390x": {
      "version": "0.34.1",
      "resolved": "https://registry.npmjs.org/@img/sharp-linux-s390x/-/sharp-linux-s390x-0.34.1.tgz",
      "integrity": "sha512-7s0KX2tI9mZI2buRipKIw2X1ufdTeaRgwmRabt5bi9chYfhur+/C1OXg3TKg/eag1W+6CCWLVmSauV1owmRPxA==",
      "cpu": [
        "s390x"
      ],
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-linux-s390x": "1.1.0"
      }
    },
    "node_modules/@img/sharp-linux-x64": {
      "version": "0.34.1",
      "resolved": "https://registry.npmjs.org/@img/sharp-linux-x64/-/sharp-linux-x64-0.34.1.tgz",
      "integrity": "sha512-wExv7SH9nmoBW3Wr2gvQopX1k8q2g5V5Iag8Zk6AVENsjwd+3adjwxtp3Dcu2QhOXr8W9NusBU6XcQUohBZ5MA==",
      "cpu": [
        "x64"
      ],
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-linux-x64": "1.1.0"
      }
    },
    "node_modules/@img/sharp-linuxmusl-arm64": {
      "version": "0.34.1",
      "resolved": "https://registry.npmjs.org/@img/sharp-linuxmusl-arm64/-/sharp-linuxmusl-arm64-0.34.1.tgz",
      "integrity": "sha512-DfvyxzHxw4WGdPiTF0SOHnm11Xv4aQexvqhRDAoD00MzHekAj9a/jADXeXYCDFH/DzYruwHbXU7uz+H+nWmSOQ==",
      "cpu": [
        "arm64"
      ],
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-linuxmusl-arm64": "1.1.0"
      }
    },
    "node_modules/@img/sharp-linuxmusl-x64": {
      "version": "0.34.1",
      "resolved": "https://registry.npmjs.org/@img/sharp-linuxmusl-x64/-/sharp-linuxmusl-x64-0.34.1.tgz",
      "integrity": "sha512-pax/kTR407vNb9qaSIiWVnQplPcGU8LRIJpDT5o8PdAx5aAA7AS3X9PS8Isw1/WfqgQorPotjrZL3Pqh6C5EBg==",
      "cpu": [
        "x64"
      ],
      "license": "Apache-2.0",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-libvips-linuxmusl-x64": "1.1.0"
      }
    },
    "node_modules/@img/sharp-wasm32": {
      "version": "0.34.1",
      "resolved": "https://registry.npmjs.org/@img/sharp-wasm32/-/sharp-wasm32-0.34.1.tgz",
      "integrity": "sha512-YDybQnYrLQfEpzGOQe7OKcyLUCML4YOXl428gOOzBgN6Gw0rv8dpsJ7PqTHxBnXnwXr8S1mYFSLSa727tpz0xg==",
      "cpu": [
        "wasm32"
      ],
      "license": "Apache-2.0 AND LGPL-3.0-or-later AND MIT",
      "optional": true,
      "dependencies": {
        "@emnapi/runtime": "^1.4.0"
      },
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-win32-ia32": {
      "version": "0.34.1",
      "resolved": "https://registry.npmjs.org/@img/sharp-win32-ia32/-/sharp-win32-ia32-0.34.1.tgz",
      "integrity": "sha512-WKf/NAZITnonBf3U1LfdjoMgNO5JYRSlhovhRhMxXVdvWYveM4kM3L8m35onYIdh75cOMCo1BexgVQcCDzyoWw==",
      "cpu": [
        "ia32"
      ],
      "license": "Apache-2.0 AND LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@img/sharp-win32-x64": {
      "version": "0.34.1",
      "resolved": "https://registry.npmjs.org/@img/sharp-win32-x64/-/sharp-win32-x64-0.34.1.tgz",
      "integrity": "sha512-hw1iIAHpNE8q3uMIRCgGOeDoz9KtFNarFLQclLxr/LK1VBkj8nby18RjFvr6aP7USRYAjTZW6yisnBWMX571Tw==",
      "cpu": [
        "x64"
      ],
      "license": "Apache-2.0 AND LGPL-3.0-or-later",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      }
    },
    "node_modules/@next/env": {
      "version": "15.3.1",
      "resolved": "https://registry.npmjs.org/@next/env/-/env-15.3.1.tgz",
      "integrity": "sha512-cwK27QdzrMblHSn9DZRV+DQscHXRuJv6MydlJRpFSqJWZrTYMLzKDeyueJNN9MGd8NNiUKzDQADAf+dMLXX7YQ==",
      "license": "MIT"
    },
    "node_modules/@next/swc-darwin-arm64": {
      "version": "15.3.1",
      "resolved": "https://registry.npmjs.org/@next/swc-darwin-arm64/-/swc-darwin-arm64-15.3.1.tgz",
      "integrity": "sha512-hjDw4f4/nla+6wysBL07z52Gs55Gttp5Bsk5/8AncQLJoisvTBP0pRIBK/B16/KqQyH+uN4Ww8KkcAqJODYH3w==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@next/swc-darwin-x64": {
      "version": "15.3.1",
      "resolved": "https://registry.npmjs.org/@next/swc-darwin-x64/-/swc-darwin-x64-15.3.1.tgz",
      "integrity": "sha512-q+aw+cJ2ooVYdCEqZVk+T4Ni10jF6Fo5DfpEV51OupMaV5XL6pf3GCzrk6kSSZBsMKZtVC1Zm/xaNBFpA6bJ2g==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@next/swc-linux-arm64-gnu": {
      "version": "15.3.1",
      "resolved": "https://registry.npmjs.org/@next/swc-linux-arm64-gnu/-/swc-linux-arm64-gnu-15.3.1.tgz",
      "integrity": "sha512-wBQ+jGUI3N0QZyWmmvRHjXjTWFy8o+zPFLSOyAyGFI94oJi+kK/LIZFJXeykvgXUk1NLDAEFDZw/NVINhdk9FQ==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@next/swc-linux-arm64-musl": {
      "version": "15.3.1",
      "resolved": "https://registry.npmjs.org/@next/swc-linux-arm64-musl/-/swc-linux-arm64-musl-15.3.1.tgz",
      "integrity": "sha512-IIxXEXRti/AulO9lWRHiCpUUR8AR/ZYLPALgiIg/9ENzMzLn3l0NSxVdva7R/VDcuSEBo0eGVCe3evSIHNz0Hg==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@next/swc-linux-x64-gnu": {
      "version": "15.3.1",
      "resolved": "https://registry.npmjs.org/@next/swc-linux-x64-gnu/-/swc-linux-x64-gnu-15.3.1.tgz",
      "integrity": "sha512-bfI4AMhySJbyXQIKH5rmLJ5/BP7bPwuxauTvVEiJ/ADoddaA9fgyNNCcsbu9SlqfHDoZmfI6g2EjzLwbsVTr5A==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@next/swc-linux-x64-musl": {
      "version": "15.3.1",
      "resolved": "https://registry.npmjs.org/@next/swc-linux-x64-musl/-/swc-linux-x64-musl-15.3.1.tgz",
      "integrity": "sha512-FeAbR7FYMWR+Z+M5iSGytVryKHiAsc0x3Nc3J+FD5NVbD5Mqz7fTSy8CYliXinn7T26nDMbpExRUI/4ekTvoiA==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@next/swc-win32-arm64-msvc": {
      "version": "15.3.1",
      "resolved": "https://registry.npmjs.org/@next/swc-win32-arm64-msvc/-/swc-win32-arm64-msvc-15.3.1.tgz",
      "integrity": "sha512-yP7FueWjphQEPpJQ2oKmshk/ppOt+0/bB8JC8svPUZNy0Pi3KbPx2Llkzv1p8CoQa+D2wknINlJpHf3vtChVBw==",
      "cpu": [
        "arm64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@next/swc-win32-x64-msvc": {
      "version": "15.3.1",
      "resolved": "https://registry.npmjs.org/@next/swc-win32-x64-msvc/-/swc-win32-x64-msvc-15.3.1.tgz",
      "integrity": "sha512-3PMvF2zRJAifcRNni9uMk/gulWfWS+qVI/pagd+4yLF5bcXPZPPH2xlYRYOsUjmCJOXSTAC2PjRzbhsRzR2fDQ==",
      "cpu": [
        "x64"
      ],
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">= 10"
      }
    },
    "node_modules/@swc/counter": {
      "version": "0.1.3",
      "resolved": "https://registry.npmjs.org/@swc/counter/-/counter-0.1.3.tgz",
      "integrity": "sha512-e2BR4lsJkkRlKZ/qCHPw9ZaSxc0MVUd7gtbtaB7aMvHeJVYe8sOB8DBZkP2DtISHGSku9sCK6T6cnY0CtXrOCQ==",
      "license": "Apache-2.0"
    },
    "node_modules/@swc/helpers": {
      "version": "0.5.15",
      "resolved": "https://registry.npmjs.org/@swc/helpers/-/helpers-0.5.15.tgz",
      "integrity": "sha512-JQ5TuMi45Owi4/BIMAJBoSQoOJu12oOk/gADqlcUL9JEdHB8vyjUSsxqeNXnmXHjYKMi2WcYtezGEEhqUI/E2g==",
      "license": "Apache-2.0",
      "dependencies": {
        "tslib": "^2.8.0"
      }
    },
    "node_modules/@types/node": {
      "version": "20.17.30",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-20.17.30.tgz",
      "integrity": "sha512-7zf4YyHA+jvBNfVrk2Gtvs6x7E8V+YDW05bNfG2XkWDJfYRXrTiP/DsB2zSYTaHX0bGIujTBQdMVAhb+j7mwpg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "undici-types": "~6.19.2"
      }
    },
    "node_modules/@types/react": {
      "version": "19.1.2",
      "resolved": "https://registry.npmjs.org/@types/react/-/react-19.1.2.tgz",
      "integrity": "sha512-oxLPMytKchWGbnQM9O7D67uPa9paTNxO7jVoNMXgkkErULBPhPARCfkKL9ytcIJJRGjbsVwW4ugJzyFFvm/Tiw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "csstype": "^3.0.2"
      }
    },
    "node_modules/@types/react-dom": {
      "version": "19.1.2",
      "resolved": "https://registry.npmjs.org/@types/react-dom/-/react-dom-19.1.2.tgz",
      "integrity": "sha512-XGJkWF41Qq305SKWEILa1O8vzhb3aOo3ogBlSmiqNko/WmRb6QIaweuZCXjKygVDXpzXb5wyxKTSOsmkuqj+Qw==",
      "dev": true,
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "^19.0.0"
      }
    },
    "node_modules/autoprefixer": {
      "version": "10.4.21",
      "resolved": "https://registry.npmjs.org/autoprefixer/-/autoprefixer-10.4.21.tgz",
      "integrity": "sha512-O+A6LWV5LDHSJD3LjHYoNi4VLsj/Whi7k6zG12xTYaU4cQ8oxQGckXNX8cRHK5yOZ/ppVHe0ZBXGzSV9jXdVbQ==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/autoprefixer"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "browserslist": "^4.24.4",
        "caniuse-lite": "^1.0.30001702",
        "fraction.js": "^4.3.7",
        "normalize-range": "^0.1.2",
        "picocolors": "^1.1.1",
        "postcss-value-parser": "^4.2.0"
      },
      "bin": {
        "autoprefixer": "bin/autoprefixer"
      },
      "engines": {
        "node": "^10 || ^12 || >=14"
      },
      "peerDependencies": {
        "postcss": "^8.1.0"
      }
    },
    "node_modules/browserslist": {
      "version": "4.24.5",
      "resolved": "https://registry.npmjs.org/browserslist/-/browserslist-4.24.5.tgz",
      "integrity": "sha512-FDToo4Wo82hIdgc1CQ+NQD0hEhmpPjrZ3hiUgwgOG6IuTdlpr8jdjyG24P6cNP1yJpTLzS5OcGgSw0xmDU1/Tw==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/browserslist"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "caniuse-lite": "^1.0.30001716",
        "electron-to-chromium": "^1.5.149",
        "node-releases": "^2.0.19",
        "update-browserslist-db": "^1.1.3"
      },
      "bin": {
        "browserslist": "cli.js"
      },
      "engines": {
        "node": "^6 || ^7 || ^8 || ^9 || ^10 || ^11 || ^12 || >=13.7"
      }
    },
    "node_modules/busboy": {
      "version": "1.6.0",
      "resolved": "https://registry.npmjs.org/busboy/-/busboy-1.6.0.tgz",
      "integrity": "sha512-8SFQbg/0hQ9xy3UNTB0YEnsNBbWfhf7RtnzpL7TkBiTBRfrQ9Fxcnz7VJsleJpyp6rVLvXiuORqjlHi5q+PYuA==",
      "dependencies": {
        "streamsearch": "^1.1.0"
      },
      "engines": {
        "node": ">=10.16.0"
      }
    },
    "node_modules/caniuse-lite": {
      "version": "1.0.30001717",
      "resolved": "https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001717.tgz",
      "integrity": "sha512-auPpttCq6BDEG8ZAuHJIplGw6GODhjw+/11e7IjpnYCxZcW/ONgPs0KVBJ0d1bY3e2+7PRe5RCLyP+PfwVgkYw==",
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/caniuse-lite"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "CC-BY-4.0"
    },
    "node_modules/client-only": {
      "version": "0.0.1",
      "resolved": "https://registry.npmjs.org/client-only/-/client-only-0.0.1.tgz",
      "integrity": "sha512-IV3Ou0jSMzZrd3pZ48nLkT9DA7Ag1pnPzaiQhpW7c3RbcqqzvzzVu+L8gfqMp/8IM2MQtSiqaCxrrcfu8I8rMA==",
      "license": "MIT"
    },
    "node_modules/cloudinary": {
      "version": "2.6.0",
      "resolved": "https://registry.npmjs.org/cloudinary/-/cloudinary-2.6.0.tgz",
      "integrity": "sha512-FIlny9RR5LPgkMioG4V7yUpC6ASyIFQMWfx4TgOi/xBeLxJTegbyQc3itiXL0b0lDlSaL0KyT2THEw6osrKqpQ==",
      "license": "MIT",
      "dependencies": {
        "lodash": "^4.17.21",
        "q": "^1.5.1"
      },
      "engines": {
        "node": ">=9"
      }
    },
    "node_modules/color": {
      "version": "4.2.3",
      "resolved": "https://registry.npmjs.org/color/-/color-4.2.3.tgz",
      "integrity": "sha512-1rXeuUUiGGrykh+CeBdu5Ie7OJwinCgQY0bc7GCRxy5xVHy+moaqkpL/jqQq0MtQOeYcrqEz4abc5f0KtU7W4A==",
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "color-convert": "^2.0.1",
        "color-string": "^1.9.0"
      },
      "engines": {
        "node": ">=12.5.0"
      }
    },
    "node_modules/color-convert": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
      "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "color-name": "~1.1.4"
      },
      "engines": {
        "node": ">=7.0.0"
      }
    },
    "node_modules/color-name": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
      "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==",
      "license": "MIT",
      "optional": true
    },
    "node_modules/color-string": {
      "version": "1.9.1",
      "resolved": "https://registry.npmjs.org/color-string/-/color-string-1.9.1.tgz",
      "integrity": "sha512-shrVawQFojnZv6xM40anx4CkoDP+fZsw/ZerEMsW/pyzsRbElpsL/DBVW7q3ExxwusdNXI3lXpuhEZkzs8p5Eg==",
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "color-name": "^1.0.0",
        "simple-swizzle": "^0.2.2"
      }
    },
    "node_modules/cookie": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/cookie/-/cookie-1.0.2.tgz",
      "integrity": "sha512-9Kr/j4O16ISv8zBBhJoi4bXOYNTkFLOqSL3UDB0njXxCXNezjeyVrJyGOWtgfs/q2km1gwBcfH8q1yEGoMYunA==",
      "license": "MIT",
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/csstype": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/csstype/-/csstype-3.1.3.tgz",
      "integrity": "sha512-M1uQkMl8rQK/szD0LNhtqxIPLpimGm8sOBwU7lLnCpSbTyY3yeU1Vc7l4KT5zT4s/yOxHH5O7tIuuLOCnLADRw==",
      "license": "MIT"
    },
    "node_modules/dequal": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/dequal/-/dequal-2.0.3.tgz",
      "integrity": "sha512-0je+qPKHEMohvfRTCEo3CrPG6cAzAYgmzKyxRiYSSDkS6eGJdyVJm7WaYA5ECaAD9wLB2T4EEeymA5aFVcYXCA==",
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/detect-libc": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/detect-libc/-/detect-libc-2.0.4.tgz",
      "integrity": "sha512-3UDv+G9CsCKO1WKMGw9fwq/SWJYbI0c5Y7LU1AXYoDdbhE2AHQ6N6Nb34sG8Fj7T5APy8qXDCKuuIHd1BR0tVA==",
      "license": "Apache-2.0",
      "optional": true,
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/dot-case": {
      "version": "3.0.4",
      "resolved": "https://registry.npmjs.org/dot-case/-/dot-case-3.0.4.tgz",
      "integrity": "sha512-Kv5nKlh6yRrdrGvxeJ2e5y2eRUpkUosIW4A2AS38zwSz27zu7ufDwQPi5Jhs3XAlGNetl3bmnGhQsMtkKJnj3w==",
      "license": "MIT",
      "dependencies": {
        "no-case": "^3.0.4",
        "tslib": "^2.0.3"
      }
    },
    "node_modules/electron-to-chromium": {
      "version": "1.5.150",
      "resolved": "https://registry.npmjs.org/electron-to-chromium/-/electron-to-chromium-1.5.150.tgz",
      "integrity": "sha512-rOOkP2ZUMx1yL4fCxXQKDHQ8ZXwisb2OycOQVKHgvB3ZI4CvehOd4y2tfnnLDieJ3Zs1RL1Dlp3cMkyIn7nnXA==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/escalade": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/escalade/-/escalade-3.2.0.tgz",
      "integrity": "sha512-WUj2qlxaQtO4g6Pq5c29GTcWGDyd8itL8zTlipgECz3JesAiiOKotd8JU6otB3PACgG6xkJUyVhboMS+bje/jA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/fraction.js": {
      "version": "4.3.7",
      "resolved": "https://registry.npmjs.org/fraction.js/-/fraction.js-4.3.7.tgz",
      "integrity": "sha512-ZsDfxO51wGAXREY55a7la9LScWpwv9RxIrYABrlvOFBlH/ShPnrtsXeuUIfXKKOVicNxQ+o8JTbJvjS4M89yew==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "*"
      },
      "funding": {
        "type": "patreon",
        "url": "https://github.com/sponsors/rawify"
      }
    },
    "node_modules/framer-motion": {
      "version": "12.10.1",
      "resolved": "https://registry.npmjs.org/framer-motion/-/framer-motion-12.10.1.tgz",
      "integrity": "sha512-g+fANUVC17SzQc6eA0CtomBW4n67ckhS2hq5fjkKZneKzv7sbdXK3zzjnnAKB22Ck+Qhh+IlO5RjHNKULsq99Q==",
      "license": "MIT",
      "dependencies": {
        "motion-dom": "^12.10.1",
        "motion-utils": "^12.9.4",
        "tslib": "^2.4.0"
      },
      "peerDependencies": {
        "@emotion/is-prop-valid": "*",
        "react": "^18.0.0 || ^19.0.0",
        "react-dom": "^18.0.0 || ^19.0.0"
      },
      "peerDependenciesMeta": {
        "@emotion/is-prop-valid": {
          "optional": true
        },
        "react": {
          "optional": true
        },
        "react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/glob-to-regexp": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/glob-to-regexp/-/glob-to-regexp-0.4.1.tgz",
      "integrity": "sha512-lkX1HJXwyMcprw/5YUZc2s7DrpAiHB21/V+E1rHUrVNokkvB6bqMzT0VfV6/86ZNabt1k14YOIaT7nDvOX3Iiw==",
      "license": "BSD-2-Clause"
    },
    "node_modules/is-arrayish": {
      "version": "0.3.2",
      "resolved": "https://registry.npmjs.org/is-arrayish/-/is-arrayish-0.3.2.tgz",
      "integrity": "sha512-eVRqCvVlZbuw3GrM63ovNSNAeA1K16kaR/LRY/92w0zxQ5/1YzwblUX652i4Xs9RwAGjW9d9y6X88t8OaAJfWQ==",
      "license": "MIT",
      "optional": true
    },
    "node_modules/isows": {
      "version": "1.0.6",
      "resolved": "https://registry.npmjs.org/isows/-/isows-1.0.6.tgz",
      "integrity": "sha512-lPHCayd40oW98/I0uvgaHKWCSvkzY27LjWLbtzOm64yQ+G3Q5npjjbdppU65iZXkK1Zt+kH9pfegli0AYfwYYw==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/wevm"
        }
      ],
      "license": "MIT",
      "peerDependencies": {
        "ws": "*"
      }
    },
    "node_modules/js-cookie": {
      "version": "3.0.5",
      "resolved": "https://registry.npmjs.org/js-cookie/-/js-cookie-3.0.5.tgz",
      "integrity": "sha512-cEiJEAEoIbWfCZYKWhVwFuvPX1gETRYPw6LlaTKoxD3s2AkXzkCjnp6h0V77ozyqj0jakteJ4YqDJT830+lVGw==",
      "license": "MIT",
      "engines": {
        "node": ">=14"
      }
    },
    "node_modules/lodash": {
      "version": "4.17.21",
      "resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz",
      "integrity": "sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg==",
      "license": "MIT"
    },
    "node_modules/lower-case": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/lower-case/-/lower-case-2.0.2.tgz",
      "integrity": "sha512-7fm3l3NAF9WfN6W3JOmf5drwpVqX78JtoGJ3A6W0a6ZnldM41w2fV5D490psKFTpMds8TJse/eHLFFsNHHjHgg==",
      "license": "MIT",
      "dependencies": {
        "tslib": "^2.0.3"
      }
    },
    "node_modules/lucide-react": {
      "version": "0.503.0",
      "resolved": "https://registry.npmjs.org/lucide-react/-/lucide-react-0.503.0.tgz",
      "integrity": "sha512-HGGkdlPWQ0vTF8jJ5TdIqhQXZi6uh3LnNgfZ8MHiuxFfX3RZeA79r2MW2tHAZKlAVfoNE8esm3p+O6VkIvpj6w==",
      "license": "ISC",
      "peerDependencies": {
        "react": "^16.5.1 || ^17.0.0 || ^18.0.0 || ^19.0.0"
      }
    },
    "node_modules/map-obj": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/map-obj/-/map-obj-4.3.0.tgz",
      "integrity": "sha512-hdN1wVrZbb29eBGiGjJbeP8JbKjq1urkHJ/LIP/NY48MZ1QVXUsQBV1G1zvYFHn1XE06cwjBsOI2K3Ulnj1YXQ==",
      "license": "MIT",
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/motion-dom": {
      "version": "12.10.1",
      "resolved": "https://registry.npmjs.org/motion-dom/-/motion-dom-12.10.1.tgz",
      "integrity": "sha512-rY8DNqgKh4LeFSQBkuXpe/7sycYS9RM+4luukjHpHogF1liSvIp0Hedx0q2QsWNz+AHuZ5bZQ9j9QZSUCA8bbw==",
      "license": "MIT",
      "dependencies": {
        "motion-utils": "^12.9.4"
      }
    },
    "node_modules/motion-utils": {
      "version": "12.9.4",
      "resolved": "https://registry.npmjs.org/motion-utils/-/motion-utils-12.9.4.tgz",
      "integrity": "sha512-BW3I65zeM76CMsfh3kHid9ansEJk9Qvl+K5cu4DVHKGsI52n76OJ4z2CUJUV+Mn3uEP9k1JJA3tClG0ggSrRcg==",
      "license": "MIT"
    },
    "node_modules/nanoid": {
      "version": "3.3.11",
      "resolved": "https://registry.npmjs.org/nanoid/-/nanoid-3.3.11.tgz",
      "integrity": "sha512-N8SpfPUnUp1bK+PMYW8qSWdl9U+wwNWI4QKxOYDy9JAro3WMX7p2OeVRF9v+347pnakNevPmiHhNmZ2HbFA76w==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "bin": {
        "nanoid": "bin/nanoid.cjs"
      },
      "engines": {
        "node": "^10 || ^12 || ^13.7 || ^14 || >=15.0.1"
      }
    },
    "node_modules/next": {
      "version": "15.3.1",
      "resolved": "https://registry.npmjs.org/next/-/next-15.3.1.tgz",
      "integrity": "sha512-8+dDV0xNLOgHlyBxP1GwHGVaNXsmp+2NhZEYrXr24GWLHtt27YrBPbPuHvzlhi7kZNYjeJNR93IF5zfFu5UL0g==",
      "license": "MIT",
      "dependencies": {
        "@next/env": "15.3.1",
        "@swc/counter": "0.1.3",
        "@swc/helpers": "0.5.15",
        "busboy": "1.6.0",
        "caniuse-lite": "^1.0.30001579",
        "postcss": "8.4.31",
        "styled-jsx": "5.1.6"
      },
      "bin": {
        "next": "dist/bin/next"
      },
      "engines": {
        "node": "^18.18.0 || ^19.8.0 || >= 20.0.0"
      },
      "optionalDependencies": {
        "@next/swc-darwin-arm64": "15.3.1",
        "@next/swc-darwin-x64": "15.3.1",
        "@next/swc-linux-arm64-gnu": "15.3.1",
        "@next/swc-linux-arm64-musl": "15.3.1",
        "@next/swc-linux-x64-gnu": "15.3.1",
        "@next/swc-linux-x64-musl": "15.3.1",
        "@next/swc-win32-arm64-msvc": "15.3.1",
        "@next/swc-win32-x64-msvc": "15.3.1",
        "sharp": "^0.34.1"
      },
      "peerDependencies": {
        "@opentelemetry/api": "^1.1.0",
        "@playwright/test": "^1.41.2",
        "babel-plugin-react-compiler": "*",
        "react": "^18.2.0 || 19.0.0-rc-de68d2f4-20241204 || ^19.0.0",
        "react-dom": "^18.2.0 || 19.0.0-rc-de68d2f4-20241204 || ^19.0.0",
        "sass": "^1.3.0"
      },
      "peerDependenciesMeta": {
        "@opentelemetry/api": {
          "optional": true
        },
        "@playwright/test": {
          "optional": true
        },
        "babel-plugin-react-compiler": {
          "optional": true
        },
        "sass": {
          "optional": true
        }
      }
    },
    "node_modules/next/node_modules/postcss": {
      "version": "8.4.31",
      "resolved": "https://registry.npmjs.org/postcss/-/postcss-8.4.31.tgz",
      "integrity": "sha512-PS08Iboia9mts/2ygV3eLpY5ghnUcfLV/EXTOW1E2qYxJKGGBUtNjN76FYHnMs36RmARn41bC0AZmn+rR0OVpQ==",
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/postcss"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "nanoid": "^3.3.6",
        "picocolors": "^1.0.0",
        "source-map-js": "^1.0.2"
      },
      "engines": {
        "node": "^10 || ^12 || >=14"
      }
    },
    "node_modules/no-case": {
      "version": "3.0.4",
      "resolved": "https://registry.npmjs.org/no-case/-/no-case-3.0.4.tgz",
      "integrity": "sha512-fgAN3jGAh+RoxUGZHTSOLJIqUc2wmoBwGR4tbpNAKmmovFoWq0OdRkb0VkldReO2a2iBT/OEulG9XSUc10r3zg==",
      "license": "MIT",
      "dependencies": {
        "lower-case": "^2.0.2",
        "tslib": "^2.0.3"
      }
    },
    "node_modules/node-releases": {
      "version": "2.0.19",
      "resolved": "https://registry.npmjs.org/node-releases/-/node-releases-2.0.19.tgz",
      "integrity": "sha512-xxOWJsBKtzAq7DY0J+DTzuz58K8e7sJbdgwkbMWQe8UYB6ekmsQ45q0M/tJDsGaZmbC+l7n57UV8Hl5tHxO9uw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/normalize-range": {
      "version": "0.1.2",
      "resolved": "https://registry.npmjs.org/normalize-range/-/normalize-range-0.1.2.tgz",
      "integrity": "sha512-bdok/XvKII3nUpklnV6P2hxtMNrCboOjAcyBuQnWEhO665FwrSNRxU+AqpsyvO6LgGYPspN+lu5CLtw4jPRKNA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/picocolors": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/picocolors/-/picocolors-1.1.1.tgz",
      "integrity": "sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA==",
      "license": "ISC"
    },
    "node_modules/postcss": {
      "version": "8.5.3",
      "resolved": "https://registry.npmjs.org/postcss/-/postcss-8.5.3.tgz",
      "integrity": "sha512-dle9A3yYxlBSrt8Fu+IpjGT8SY8hN0mlaA6GY8t0P5PjIOZemULz/E2Bnm/2dcUOena75OTNkHI76uZBNUUq3A==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/postcss"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "nanoid": "^3.3.8",
        "picocolors": "^1.1.1",
        "source-map-js": "^1.2.1"
      },
      "engines": {
        "node": "^10 || ^12 || >=14"
      }
    },
    "node_modules/postcss-value-parser": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/postcss-value-parser/-/postcss-value-parser-4.2.0.tgz",
      "integrity": "sha512-1NNCs6uurfkVbeXG4S8JFT9t19m45ICnif8zWLd5oPSZ50QnwMfK+H3jv408d4jw/7Bttv5axS5IiHoLaVNHeQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/q": {
      "version": "1.5.1",
      "resolved": "https://registry.npmjs.org/q/-/q-1.5.1.tgz",
      "integrity": "sha512-kV/CThkXo6xyFEZUugw/+pIOywXcDbFYgSct5cT3gqlbkBE1SJdwy6UQoZvodiWF/ckQLZyDE/Bu1M6gVu5lVw==",
      "deprecated": "You or someone you depend on is using Q, the JavaScript Promise library that gave JavaScript developers strong feelings about promises. They can almost certainly migrate to the native JavaScript promise now. Thank you literally everyone for joining me in this bet against the odds. Be excellent to each other.\n\n(For a CapTP with native promises, see @endo/eventual-send and @endo/captp)",
      "license": "MIT",
      "engines": {
        "node": ">=0.6.0",
        "teleport": ">=0.2.0"
      }
    },
    "node_modules/react": {
      "version": "19.1.0",
      "resolved": "https://registry.npmjs.org/react/-/react-19.1.0.tgz",
      "integrity": "sha512-FS+XFBNvn3GTAWq26joslQgWNoFu08F4kl0J4CgdNKADkdSGXQyTCnKteIAJy96Br6YbpEU1LSzV5dYtjMkMDg==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/react-dom": {
      "version": "19.1.0",
      "resolved": "https://registry.npmjs.org/react-dom/-/react-dom-19.1.0.tgz",
      "integrity": "sha512-Xs1hdnE+DyKgeHJeJznQmYMIBG3TKIHJJT95Q58nHLSrElKlGQqDTR2HQ9fx5CN/Gk6Vh/kupBTDLU11/nDk/g==",
      "license": "MIT",
      "dependencies": {
        "scheduler": "^0.26.0"
      },
      "peerDependencies": {
        "react": "^19.1.0"
      }
    },
    "node_modules/react-icons": {
      "version": "5.5.0",
      "resolved": "https://registry.npmjs.org/react-icons/-/react-icons-5.5.0.tgz",
      "integrity": "sha512-MEFcXdkP3dLo8uumGI5xN3lDFNsRtrjbOEKDLD7yv76v4wpnEq2Lt2qeHaQOr34I/wPN3s3+N08WkQ+CW37Xiw==",
      "license": "MIT",
      "peerDependencies": {
        "react": "*"
      }
    },
    "node_modules/scheduler": {
      "version": "0.26.0",
      "resolved": "https://registry.npmjs.org/scheduler/-/scheduler-0.26.0.tgz",
      "integrity": "sha512-NlHwttCI/l5gCPR3D1nNXtWABUmBwvZpEQiD4IXSbIDq8BzLIK/7Ir5gTFSGZDUu37K5cMNp0hFtzO38sC7gWA==",
      "license": "MIT"
    },
    "node_modules/semver": {
      "version": "7.7.1",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.7.1.tgz",
      "integrity": "sha512-hlq8tAfn0m/61p4BVRcPzIGr6LKiMwo4VM6dGi6pt4qcRkmNzTcWq6eCEjEh+qXjkMDvPlOFFSGwQjoEa6gyMA==",
      "license": "ISC",
      "optional": true,
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/server-only": {
      "version": "0.0.1",
      "resolved": "https://registry.npmjs.org/server-only/-/server-only-0.0.1.tgz",
      "integrity": "sha512-qepMx2JxAa5jjfzxG79yPPq+8BuFToHd1hm7kI+Z4zAq1ftQiP7HcxMhDDItrbtwVeLg/cY2JnKnrcFkmiswNA==",
      "license": "MIT"
    },
    "node_modules/sharp": {
      "version": "0.34.1",
      "resolved": "https://registry.npmjs.org/sharp/-/sharp-0.34.1.tgz",
      "integrity": "sha512-1j0w61+eVxu7DawFJtnfYcvSv6qPFvfTaqzTQ2BLknVhHTwGS8sc63ZBF4rzkWMBVKybo4S5OBtDdZahh2A1xg==",
      "hasInstallScript": true,
      "license": "Apache-2.0",
      "optional": true,
      "dependencies": {
        "color": "^4.2.3",
        "detect-libc": "^2.0.3",
        "semver": "^7.7.1"
      },
      "engines": {
        "node": "^18.17.0 || ^20.3.0 || >=21.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/libvips"
      },
      "optionalDependencies": {
        "@img/sharp-darwin-arm64": "0.34.1",
        "@img/sharp-darwin-x64": "0.34.1",
        "@img/sharp-libvips-darwin-arm64": "1.1.0",
        "@img/sharp-libvips-darwin-x64": "1.1.0",
        "@img/sharp-libvips-linux-arm": "1.1.0",
        "@img/sharp-libvips-linux-arm64": "1.1.0",
        "@img/sharp-libvips-linux-ppc64": "1.1.0",
        "@img/sharp-libvips-linux-s390x": "1.1.0",
        "@img/sharp-libvips-linux-x64": "1.1.0",
        "@img/sharp-libvips-linuxmusl-arm64": "1.1.0",
        "@img/sharp-libvips-linuxmusl-x64": "1.1.0",
        "@img/sharp-linux-arm": "0.34.1",
        "@img/sharp-linux-arm64": "0.34.1",
        "@img/sharp-linux-s390x": "0.34.1",
        "@img/sharp-linux-x64": "0.34.1",
        "@img/sharp-linuxmusl-arm64": "0.34.1",
        "@img/sharp-linuxmusl-x64": "0.34.1",
        "@img/sharp-wasm32": "0.34.1",
        "@img/sharp-win32-ia32": "0.34.1",
        "@img/sharp-win32-x64": "0.34.1"
      }
    },
    "node_modules/simple-swizzle": {
      "version": "0.2.2",
      "resolved": "https://registry.npmjs.org/simple-swizzle/-/simple-swizzle-0.2.2.tgz",
      "integrity": "sha512-JA//kQgZtbuY83m+xT+tXJkmJncGMTFT+C+g2h2R9uxkYIrE2yy9sgmcLhCnw57/WSD+Eh3J97FPEDFnbXnDUg==",
      "license": "MIT",
      "optional": true,
      "dependencies": {
        "is-arrayish": "^0.3.1"
      }
    },
    "node_modules/snake-case": {
      "version": "3.0.4",
      "resolved": "https://registry.npmjs.org/snake-case/-/snake-case-3.0.4.tgz",
      "integrity": "sha512-LAOh4z89bGQvl9pFfNF8V146i7o7/CqFPbqzYgP+yYzDIDeS9HaNFtXABamRW+AQzEVODcvE79ljJ+8a9YSdMg==",
      "license": "MIT",
      "dependencies": {
        "dot-case": "^3.0.4",
        "tslib": "^2.0.3"
      }
    },
    "node_modules/snakecase-keys": {
      "version": "8.0.1",
      "resolved": "https://registry.npmjs.org/snakecase-keys/-/snakecase-keys-8.0.1.tgz",
      "integrity": "sha512-Sj51kE1zC7zh6TDlNNz0/Jn1n5HiHdoQErxO8jLtnyrkJW/M5PrI7x05uDgY3BO7OUQYKCvmeMurW6BPUdwEOw==",
      "license": "MIT",
      "dependencies": {
        "map-obj": "^4.1.0",
        "snake-case": "^3.0.4",
        "type-fest": "^4.15.0"
      },
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/source-map-js": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/source-map-js/-/source-map-js-1.2.1.tgz",
      "integrity": "sha512-UXWMKhLOwVKb728IUtQPXxfYU+usdybtUrK/8uGE8CQMvrhOpwvzDBwj0QhSL7MQc7vIsISBG8VQ8+IDQxpfQA==",
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/std-env": {
      "version": "3.9.0",
      "resolved": "https://registry.npmjs.org/std-env/-/std-env-3.9.0.tgz",
      "integrity": "sha512-UGvjygr6F6tpH7o2qyqR6QYpwraIjKSdtzyBdyytFOHmPZY917kwdwLG0RbOjWOnKmnm3PeHjaoLLMie7kPLQw==",
      "license": "MIT"
    },
    "node_modules/streamsearch": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/streamsearch/-/streamsearch-1.1.0.tgz",
      "integrity": "sha512-Mcc5wHehp9aXz1ax6bZUyY5afg9u2rv5cqQI3mRrYkGC8rW2hM02jWuwjtL++LS5qinSyhj2QfLyNsuc+VsExg==",
      "engines": {
        "node": ">=10.0.0"
      }
    },
    "node_modules/styled-jsx": {
      "version": "5.1.6",
      "resolved": "https://registry.npmjs.org/styled-jsx/-/styled-jsx-5.1.6.tgz",
      "integrity": "sha512-qSVyDTeMotdvQYoHWLNGwRFJHC+i+ZvdBRYosOFgC+Wg1vx4frN2/RG/NA7SYqqvKNLf39P2LSRA2pu6n0XYZA==",
      "license": "MIT",
      "dependencies": {
        "client-only": "0.0.1"
      },
      "engines": {
        "node": ">= 12.0.0"
      },
      "peerDependencies": {
        "react": ">= 16.8.0 || 17.x.x || ^18.0.0-0 || ^19.0.0-0"
      },
      "peerDependenciesMeta": {
        "@babel/core": {
          "optional": true
        },
        "babel-plugin-macros": {
          "optional": true
        }
      }
    },
    "node_modules/surrealdb": {
      "version": "1.3.2",
      "resolved": "https://registry.npmjs.org/surrealdb/-/surrealdb-1.3.2.tgz",
      "integrity": "sha512-mL7nij33iuon3IQP72F46fgX3p2LAxFCWCBDbZB7IohZ13RTEwJVNq7nZeP1eMSceQUpKzS6OHIWOuF9LYAkNw==",
      "license": "Apache-2.0",
      "dependencies": {
        "isows": "^1.0.6",
        "uuidv7": "^1.0.1"
      },
      "engines": {
        "node": ">=18.0.0"
      },
      "peerDependencies": {
        "tslib": "^2.6.3",
        "typescript": "^5.0.0"
      }
    },
    "node_modules/swr": {
      "version": "2.3.3",
      "resolved": "https://registry.npmjs.org/swr/-/swr-2.3.3.tgz",
      "integrity": "sha512-dshNvs3ExOqtZ6kJBaAsabhPdHyeY4P2cKwRCniDVifBMoG/SVI7tfLWqPXriVspf2Rg4tPzXJTnwaihIeFw2A==",
      "license": "MIT",
      "dependencies": {
        "dequal": "^2.0.3",
        "use-sync-external-store": "^1.4.0"
      },
      "peerDependencies": {
        "react": "^16.11.0 || ^17.0.0 || ^18.0.0 || ^19.0.0"
      }
    },
    "node_modules/tailwindcss": {
      "version": "4.1.5",
      "resolved": "https://registry.npmjs.org/tailwindcss/-/tailwindcss-4.1.5.tgz",
      "integrity": "sha512-nYtSPfWGDiWgCkwQG/m+aX83XCwf62sBgg3bIlNiiOcggnS1x3uVRDAuyelBFL+vJdOPPCGElxv9DjHJjRHiVA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/tslib": {
      "version": "2.8.1",
      "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.8.1.tgz",
      "integrity": "sha512-oJFu94HQb+KVduSUQL7wnpmqnfmLsOA/nAh6b6EH0wCEoK0/mPeXU6c3wKDV83MkOuHPRHtSXKKU99IBazS/2w==",
      "license": "0BSD"
    },
    "node_modules/type-fest": {
      "version": "4.40.0",
      "resolved": "https://registry.npmjs.org/type-fest/-/type-fest-4.40.0.tgz",
      "integrity": "sha512-ABHZ2/tS2JkvH1PEjxFDTUWC8dB5OsIGZP4IFLhR293GqT5Y5qB1WwL2kMPYhQW9DVgVD8Hd7I8gjwPIf5GFkw==",
      "license": "(MIT OR CC0-1.0)",
      "engines": {
        "node": ">=16"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/typescript": {
      "version": "5.8.3",
      "resolved": "https://registry.npmjs.org/typescript/-/typescript-5.8.3.tgz",
      "integrity": "sha512-p1diW6TqL9L07nNxvRMM7hMMw4c5XOo/1ibL4aAIGmSAt9slTE1Xgw5KWuof2uTOvCg9BY7ZRi+GaF+7sfgPeQ==",
      "license": "Apache-2.0",
      "bin": {
        "tsc": "bin/tsc",
        "tsserver": "bin/tsserver"
      },
      "engines": {
        "node": ">=14.17"
      }
    },
    "node_modules/undici-types": {
      "version": "6.19.8",
      "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-6.19.8.tgz",
      "integrity": "sha512-ve2KP6f/JnbPBFyobGHuerC9g1FYGn/F8n1LWTwNxCEzd6IfqTwUQcNXgEtmmQ6DlRrC1hrSrBnCZPokRrDHjw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/update-browserslist-db": {
      "version": "1.1.3",
      "resolved": "https://registry.npmjs.org/update-browserslist-db/-/update-browserslist-db-1.1.3.tgz",
      "integrity": "sha512-UxhIZQ+QInVdunkDAaiazvvT/+fXL5Osr0JZlJulepYu6Jd7qJtDZjlur0emRlT71EN3ScPoE7gvsuIKKNavKw==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/browserslist"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "escalade": "^3.2.0",
        "picocolors": "^1.1.1"
      },
      "bin": {
        "update-browserslist-db": "cli.js"
      },
      "peerDependencies": {
        "browserslist": ">= 4.21.0"
      }
    },
    "node_modules/use-sync-external-store": {
      "version": "1.5.0",
      "resolved": "https://registry.npmjs.org/use-sync-external-store/-/use-sync-external-store-1.5.0.tgz",
      "integrity": "sha512-Rb46I4cGGVBmjamjphe8L/UnvJD+uPPtTkNvX5mZgqdbavhI4EbgIWJiIHXJ8bc/i9EQGPRh4DwEURJ552Do0A==",
      "license": "MIT",
      "peerDependencies": {
        "react": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0"
      }
    },
    "node_modules/uuidv7": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/uuidv7/-/uuidv7-1.0.2.tgz",
      "integrity": "sha512-8JQkH4ooXnm1JCIhqTMbtmdnYEn6oKukBxHn1Ic9878jMkL7daTI7anTExfY18VRCX7tcdn5quzvCb6EWrR8PA==",
      "license": "Apache-2.0",
      "bin": {
        "uuidv7": "cli.js"
      }
    },
    "node_modules/ws": {
      "version": "8.18.1",
      "resolved": "https://registry.npmjs.org/ws/-/ws-8.18.1.tgz",
      "integrity": "sha512-RKW2aJZMXeMxVpnZ6bck+RswznaxmzdULiBr6KY7XkTnW8uvt0iT9H5DkHUChXrc+uurzwa0rVI16n/Xzjdz1w==",
      "license": "MIT",
      "peer": true,
      "engines": {
        "node": ">=10.0.0"
      },
      "peerDependencies": {
        "bufferutil": "^4.0.1",
        "utf-8-validate": ">=5.0.2"
      },
      "peerDependenciesMeta": {
        "bufferutil": {
          "optional": true
        },
        "utf-8-validate": {
          "optional": true
        }
      }
    }
  }
}


package.json
{
  "name": "blog-platform",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@clerk/nextjs": "^6.18.0",
    "cloudinary": "^2.6.0",
    "framer-motion": "^12.10.1",
    "lucide-react": "^0.503.0",
    "next": "15.3.1",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-icons": "^5.5.0",
    "surrealdb": "^1.3.2"
  },
  "devDependencies": {
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "autoprefixer": "^10.4.21",
    "postcss": "^8.5.3",
    "tailwindcss": "^4.1.5",
    "typescript": "^5"
  }
}


tsconfig.json
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}


types\globals.d.ts
export type Roles = 'admin' | 'moderator';

declare global {
  interface CustomJwtSessionClaims {
    metadata: {
      role?: Roles;
    };
  }
}


utils\roles.ts
import { Roles } from '@/types/globals'
import { auth } from '@clerk/nextjs/server'

export const checkRole = async (role: Roles) => {
  const { sessionClaims } = await auth()
  return sessionClaims?.metadata.role === role
}
